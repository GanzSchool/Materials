---
title: Number t√≠pus a JavaScriptben
---

A JavaScriptben a Number t√≠pus szolg√°l arra, hogy eg√©sz sz√°mokat √©s val√≥s sz√°mokat (tizedest√∂rteket) kezelje.

A JavaScript a sz√°mokat a 64 bites lebeg≈ëpontos form√°tumban √°br√°zolja, amelyet az IEEE 754 szabv√°ny hat√°roz meg. Ez azt jelenti, hogy k√©pes olyan nagy sz√°mokat √°br√°zolni, mint ¬±1,7976931348623157 √ó 10¬π‚Å∞‚Å∏, √©s olyan kicsiket, mint ¬±5 √ó 10‚Åª¬≥¬≤‚Å¥.

A JavaScript sz√°mform√°tuma pontosan k√©pes √°br√°zolni minden eg√©sz sz√°mot ‚àí9 007 199 254 740 992 (‚àí2‚Åµ¬≥) √©s 9 007 199 254 740 992 (2‚Åµ¬≥) k√∂z√∂tt, bele√©rtve ezeket a hat√°r√©rt√©keket is. Ha enn√©l nagyobb eg√©sz √©rt√©keket haszn√°lsz, elveszhet a pontoss√°g a sz√°mjegyek v√©g√©n.

A JavaScriptben vannak olyan m≈±veletek, amelyek 32 bites eg√©sz sz√°mokkal t√∂rt√©nnek.

Bizonyos m≈±veletek (p√©ld√°ul a t√∂mbindexel√©s vagy a bitm≈±veletek) a JavaScriptben nem a teljes 64 bites sz√°mform√°tumot haszn√°lj√°k, hanem csak 32 bites eg√©sz sz√°mokkal dolgoznak. Ez hat√°ssal lehet a m≈±veletek eredm√©ny√©re, ha nagyon nagy vagy nagyon kicsi sz√°mokkal dolgozol.

<details className="dropdown-task">

  <summary><strong>Ez azt jelenti hogy:</strong></summary>

Vegy√ºnk egy egyszer≈± p√©ld√°t.

Tegy√ºk fel, hogy van egy sz√°munk, amely t√∫l nagy ahhoz, hogy 32 bites eg√©sz sz√°mk√©nt pontosan √°br√°zolhat√≥ legyen.

#### AND

JavaScriptben, ha k√©t sz√°mra alkalmazunk bitm≈±veletet (p√©ld√°ul **AND**), akkor a sz√°mokat el≈ësz√∂r 32 bites form√°tumban √°br√°zolja. Ez√©rt ha t√∫l nagy sz√°mokkal dolgozunk, azok nem biztos, hogy a v√°rt eredm√©nyt adj√°k.

```javascript
let a = 0xFFFFFFFF;  // A 32 bites sz√°m legnagyobb √©rt√©ke (4294967295)
let b = 0x1;          // Egy nagyon kicsi sz√°m

let result = a & b;
console.log(result);  // Kimenet: 1
```

Ebben az esetben **a** egy 32 bites sz√°m legnagyobb √©rt√©ke (0xFFFFFFFF), ami egy 32 bites bin√°ris sz√°mk√©nt `11111111111111111111111111111111` n√©z ki. Ha alkalmazzuk az **AND** oper√°tort a 0x1-el (ami csak egy bitet tartalmaz), akkor az eredm√©ny csak az utols√≥ bitet √©rinti, √©s az **1** lesz.

#### Mi√©rt van ez hat√°ssal a sz√°mokra?

A 32 bites korl√°toz√°s azt jelenti, hogy az oper√°ci√≥k csak ennyi bitet figyelembe v√©ve t√∂rt√©nnek, √≠gy ha enn√©l nagyobb sz√°mot pr√≥b√°lsz kezelni, az √©rt√©kek "lefelejt≈ëdnek", √©s pontatlan lesz az eredm√©ny

#### P√©lda 2: Sz√°mok √°tvitele bitm≈±veletekkel

```javascript
let num = 2147483648;  // 2^31, egy 33 bites sz√°m
let result = num & 0xFFFFFFFF;  // Bitwise AND a 32 bites maszkkal

console.log(result);  // Kimenet: 0
```

Ebben az esetben **num** egy 33 bites sz√°m (2^31), de mivel a bitm≈±velet csak 32 bites eg√©sz sz√°mokkal t√∂rt√©nik, az eredm√©ny **0** lesz, mivel a 33. bit lemarad.

#### Mi a l√©nyeg?

A 32 bites sz√°mform√°tum miatt a sz√°mok bizonyos m≈±veletek k√∂zben "elvesz√≠tik" a nagyobb biteket, √©s csak az als√≥ 32 bitet tartj√°k meg. Ez eredm√©nyezhet v√°ratlan viselked√©st, ha olyan m≈±veleteket hajtasz v√©gre, amelyek t√∫l nagy sz√°mokat √©rintenek.


Mit jelent az, hogy valami 32 bites?

A "32 bites" kifejez√©s arra utal, hogy egy sz√°m vagy adat 32 bit (vagyis 32 darab 0-b√≥l √©s 1-b≈ël √°ll√≥ egys√©g) hossz√∫s√°g√∫. A sz√°m√≠t√≥g√©pes rendszerekben a "bit" a legkisebb adategys√©g, amely 0 vagy 1 √©rt√©ket vehet fel. A "bites" kifejez√©s teh√°t arra utal, hogy egy adat t√°rol√°sa vagy feldolgoz√°sa sor√°n 32 darab 0 √©s 1-b≈ël √°ll√≥ kombin√°ci√≥val dolgozunk.

P√©ld√°ul, ha egy sz√°m 32 bites, akkor azt √∫gy √°br√°zoljuk, hogy 32 darab bin√°ris sz√°mjegyb≈ël (0 √©s 1) √°ll. Ez a k√∂vetkez≈ëk√©ppen n√©zhet ki:

- 32 bites sz√°m bin√°ris form√°tumban: `11111111111111111111111111111111` (ez egy 32 darab 1-b≈ël √°ll√≥ sz√°m).
- Ez a sz√°m 4 b√°jtnyi (1 b√°jt = 8 bit) helyet foglal el a mem√≥ri√°ban.

</details>

<details className="dropdown-task">

  <summary><strong>Mit jelent az, hogy valami 32 meg 64 bites?</strong></summary>

#### Hogyan m≈±k√∂dik egy 32 bites sz√°m?
- **Maxim√°lis √©rt√©k**: A 32 bites eg√©sz sz√°mok maxim√°lis √©rt√©ke 2^31 - 1 (vagyis 2,147,483,647), ha az adat el≈ëjellel (plusz √©s m√≠nusz sz√°mok) van t√°rolva. Ha nincs el≈ëjel, akkor a maxim√°lis √©rt√©k 2^32 - 1 (vagyis 4,294,967,295).
- **Minim√°lis √©rt√©k**: A negat√≠v sz√°mok a legnagyobb bitet (az √∫n. "jelz≈ëbitet") haszn√°lj√°k, teh√°t a 32 bites el≈ëjeles eg√©sz sz√°mok minim√°lis √©rt√©ke -2^31, azaz -2,147,483,648.

#### Mi√©rt fontos a "32 bites" jelz√©s?
A "32 bites" kifejez√©s seg√≠t meghat√°rozni, hogy mennyi adat f√©r el egy adott mem√≥riahelyen vagy regiszterben. A rendszer, a programok √©s az oper√°ci√≥s rendszerek 32 bites architekt√∫r√°ja meghat√°rozza a mem√≥riakezel√©s hat√°rait, √©s hogy milyen gyorsan tudnak egyes m≈±veletek futni.

**P√©lda 32 bites sz√°mokra:**
- A sz√°mok t√°rol√°sa 32 biten azt jelenti, hogy ezek az adatok nem foglalhatnak el t√∂bbet, mint 32 bitet (4 b√°jt).
- A bitm≈±veletek (pl. bitwise AND, OR) is 32 bites adatokat kezelnek, √≠gy amikor a sz√°mokat 32 bites form√°tumban haszn√°lj√°k, a sz√°m√≠t√≥g√©p csak 32 bitet vesz figyelembe a sz√°mok manipul√°l√°sakor.

A **64 bites** ugyan√∫gy egy adat t√°rol√°s√°nak vagy feldolgoz√°s√°nak form√°tuma, de itt **64 bitet** haszn√°lunk. Azaz a sz√°mok vagy adatok 64 darab 0-b√≥l √©s 1-b≈ël √°llnak, teh√°t egy-egy sz√°m vagy adat k√©tszer akkora helyet foglal el a mem√≥ri√°ban, mint egy 32 bites adat.

#### Hogyan m≈±k√∂dik a 64 bites sz√°m?

- **Maxim√°lis √©rt√©k**: A 64 bites el≈ëjeles eg√©sz sz√°mok maxim√°lis √©rt√©ke 2^63 - 1 (vagyis 9,223,372,036,854,775,807). Ha nincs el≈ëjel, akkor a maxim√°lis √©rt√©k 2^64 - 1, azaz 18,446,744,073,709,551,615.
- **Minim√°lis √©rt√©k**: A 64 bites el≈ëjeles eg√©sz sz√°mok minim√°lis √©rt√©ke -2^63, azaz -9,223,372,036,854,775,808.

Ez azt jelenti, hogy a 64 bites sz√°mok sokkal nagyobb √©s kisebb √©rt√©keket k√©pesek √°br√°zolni, mint a 32 bites sz√°mok. 

#### Mi√©rt fontos a "64 bites" jelz√©s?

A "64 bites" kifejez√©s az adatkezel√©s √©s mem√≥riafelhaszn√°l√°s ter√©n jelent≈ës k√ºl√∂nbs√©geket jelent a sz√°m√≠t√≥g√©pekben, mivel a rendszer k√©pes nagyobb sz√°mok t√°rol√°s√°ra √©s gyorsabb adatfeldolgoz√°sra, mivel egyetlen m≈±veletben k√©tszer annyi adatot tud kezelni, mint a 32 bites rendszerek.

A 64 bites architekt√∫r√°k el≈ënyei:
- **Nagyobb mem√≥ria**: Mivel a c√≠mek 64 biten vannak t√°rolva, a 64 bites rendszerek sokkal nagyobb mem√≥ria c√≠mtartom√°nyt k√©pesek kezelni (ak√°r 18,4 milli√°rd gigab√°jtot, vagyis 18 exab√°jt).
- **Nagyobb sz√°mok**: A 64 bites sz√°mok k√©pesek sokkal nagyobb √©s kisebb sz√°mokat t√°rolni, √≠gy jobban illeszkednek a tudom√°nyos sz√°m√≠t√°sokhoz, titkos√≠t√°shoz √©s m√°s olyan alkalmaz√°sokhoz, ahol nagy precizit√°sra √©s sz√©les √©rt√©ktartom√°nyra van sz√ºks√©g.

#### P√©lda 64 bites sz√°mokra:

- **64 bites sz√°m bin√°ris form√°tumban**:  
  `1111111111111111111111111111111111111111111111111111111111111111` (64 darab 1-b≈ël √°ll√≥ sz√°m).
  
  Ez egy 64 bites bin√°ris sz√°m, ami 8 b√°jt (64 bit) mem√≥riahelyet foglal el.

- **Maxim√°lis √©rt√©k**:  
  A maxim√°lis 64 bites sz√°m, ha el≈ëjel n√©lk√ºli (unsigned), 18,446,744,073,709,551,615, m√≠g el≈ëjeles eg√©sz sz√°mk√©nt a maxim√°lis √©rt√©k 9,223,372,036,854,775,807.

#### Hogyan n√©z ki a 64 bites t√°rol√°s?

A 64 bites form√°tum nagyobb sz√°mok t√°rol√°s√°ra alkalmas, teh√°t p√©ld√°ul:
- **32 bites sz√°mok eset√©ben**: a legnagyobb sz√°m, amit √°br√°zolhatunk, 4,294,967,295.
- **64 bites sz√°mok eset√©ben**: a legnagyobb sz√°m 18,446,744,073,709,551,615.

#### 64 bites √©s 32 bites √∂sszehasonl√≠t√°s:

- **32 bites rendszer**: 32 bit = 4 b√°jt. A legnagyobb sz√°m, amit t√°rolhatunk, 4,294,967,295.
- **64 bites rendszer**: 64 bit = 8 b√°jt. A legnagyobb sz√°m, amit t√°rolhatunk, 18,446,744,073,709,551,615.

A 64 bites sz√°mok teh√°t k√©tszer annyi helyet ig√©nyelnek, √≠gy sokkal nagyobb sz√°mok kezel√©s√©re k√©pesek.

</details>

---

## Integer Literals

Az Integer Literals kifejez√©s az eg√©sz sz√°m√∫ liter√°lokat jel√∂li, teh√°t olyan sz√°mokat, amelyek nem tartalmaznak tizedesjegyeket, √©s egy eg√©sz sz√°mot k√©pviselnek. JavaScript-ben az eg√©sz sz√°m√∫ liter√°lok olyan sz√°mok, mint p√©ld√°ul 10, -42, 1000.
A javaScript k√©pes √©rtelmezni a k√ºl√∂nb≈ëz≈ë sz√°mrendszerekhez tartoz√≥ integer √©rt√©keket.

**Alap√©rtelmezett t√≠pus (decim√°lis) liter√°lok**:  
   A JavaScript-ben az eg√©sz sz√°mokat alap√©rtelmez√©s szerint t√≠zes sz√°mrendszerben (base-10) √≠rjuk, teh√°t sima sz√°mjegyeket haszn√°lunk, mint p√©ld√°ul `03` vagy `10000000`. Az ilyen sz√°mok az alap√©rtelmezett eg√©sz sz√°mok.

**Hexadecim√°lis (16-os sz√°mrendszer) liter√°lok**:  
   A JavaScript t√°mogatja a hexadecim√°lis sz√°mokat is, amelyek `0x` vagy `0X` el≈ëtaggal kezd≈ëdnek, √©s ut√°na az 0‚Äì9 k√∂z√∂tti sz√°mjegyeket, illetve az `a`‚Äì`f` (vagy `A`‚Äì`F`) bet≈±ket tartalmazhatj√°k, amelyek a 10-15 √©rt√©keket k√©pviselik. P√©ld√°k:
   - `0xff` (ami 255-√∂t jelent, mivel 15 * 16 + 15 = 255)
   - `0xBADCAFE` (ami 195939070-et jelent)
   
**Bin√°ris (2-es sz√°mrendszer) √©s okt√°lis (8-as sz√°mrendszer) liter√°lok** (ES6 √©s k√©s≈ëbbi verzi√≥kban):  
   A JavaScript az ES6-t√≥l kezdve lehet≈ës√©get ad bin√°ris √©s okt√°lis sz√°mok kifejez√©s√©re is:
   - **Bin√°ris sz√°mok** `0b` vagy `0B` el≈ëtaggal, p√©ld√°ul `0b10101` (ami 21-et jelent)
   - **Okt√°lis sz√°mok** `0o` vagy `0O` el≈ëtaggal, p√©ld√°ul `0o377` (ami 255-√∂t jelent)

#### √ñsszefoglalva
- Alap√©rtelmezett a t√≠zes sz√°mrendszer (decimal), de ezn k√≠v√ºl haszn√°lat√≥ak m√©g a:
- Hexadecim√°lis sz√°mok (16-os sz√°mrendszer)
- Bin√°ris sz√°mok (2-es sz√°mrendszer)
- Okt√°lis sz√°mok (8-as sz√°mrendszer)


<details className="dropdown-task">

  <summary><strong>Gyakorlati p√©ld√°k integer liter√°lokra</strong></summary>


#### **T√≠zes sz√°mrendszer (Decimal)**
A t√≠zes sz√°mrendszer az alap√©rtelmezett sz√°mform√°tum, amit leggyakrabban haszn√°lunk.

```javascript
123           // Egyszer≈± eg√©sz sz√°m
456789        // Nagyobb sz√°m
-9876         // Negat√≠v sz√°m
```

#### **Hexadecim√°lis sz√°mrendszer (Hexadecimal)**  
A hexadecim√°lis sz√°mrendszer a `0x` el≈ëtagot haszn√°lja, √©s a sz√°mok 0‚Äì9, illetve az `a‚Äìf` karakterekb≈ël √°llnak.

```javascript
0x1A        // 26 (1 * 16 + 10)
0x7F        // 127 (7 * 16 + 15)
0xABC123    // 11256099 (10 * 16^5 + 11 * 16^4 + 12 * 16^3 + 1 * 16^2 + 2 * 16^1 + 3)
```

#### **Bin√°ris sz√°mrendszer (Binary)**  
A bin√°ris sz√°mrendszer a `0b` vagy `0B` el≈ëtagot haszn√°lja, √©s csak 0-kat √©s 1-eket tartalmaz.

```javascript
0b1010       // 10 (1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0)
0b11111111   // 255 (1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0)
0b100110101  // 309 (1 * 2^8 + 0 * 2^7 + 0 * 2^6 + 1 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0)
```

#### **Okt√°lis sz√°mrendszer (Octal)**  
Az okt√°lis sz√°mrendszer a `0o` vagy `0O` el≈ëtagot haszn√°lja, √©s a sz√°mok 0‚Äì7 k√∂z√∂tt vannak.

```javascript
0o10        // 8 (1 * 8^1 + 0 * 8^0)
0o77        // 63 (7 * 8^1 + 7 * 8^0)
0o123       // 83 (1 * 8^2 + 2 * 8^1 + 3 * 8^0)
```

#### √ñsszefoglal√°s:
- **T√≠zes sz√°mrendszer (Decimal)**: A leggyakoribb, egyszer≈± sz√°mok, p√©ld√°ul `123` vagy `-9876`.
- **Hexadecim√°lis sz√°mrendszer (Hexadecimal)**: A `0x` el≈ëtaggal, p√©ld√°ul `0x1A` vagy `0xABC123`.
- **Bin√°ris sz√°mrendszer (Binary)**: A `0b` el≈ëtaggal, p√©ld√°ul `0b1010` vagy `0b11111111`.
- **Okt√°lis sz√°mrendszer (Octal)**: A `0o` el≈ëtaggal, p√©ld√°ul `0o10` vagy `0o77`.

Ezek k√ºl√∂nb√∂z≈ë sz√°mform√°tumok, amelyeket a JavaScript t√°mogat, √©s mindegyiknek megvan a maga hasznos alkalmaz√°sa, k√ºl√∂n√∂sen sz√°m√≠t√≥g√©pes programoz√°sban √©s alacsony szint≈± m≈±veletekben.

</details>


<details className="dropdown-task">

  <summary><strong>Melyikkel hol tal√°lkozhatunk?</strong></summary>


#### **T√≠zes sz√°mrendszer (Decimal)**
A t√≠zes sz√°mrendszer az alap√©rtelmezett form√°tum a legt√∂bb programoz√°si feladatban, ahol a sz√°mok egyszer≈±en jelennek meg.

- **P√©nz√ºgyi sz√°m√≠t√°sok**: Az √°rak √©s √∂sszegek kezel√©s√©re √°ltal√°ban t√≠zes sz√°mrendszert haszn√°lunk, mert az emberek napi √©let√©ben is ezt a rendszert alkalmazzuk.

```javascript
let price = 150.75;  // Term√©k √°ra, t√≠zes sz√°mrendszerben
let tax = price * 0.2;  // Ad√≥ kisz√°m√≠t√°sa (20%)
console.log(tax);  // Ki√≠rja: 30.15
```

#### **Hexadecim√°lis sz√°mrendszer (Hexadecimal)**
A hexadecim√°lis sz√°mrendszert gyakran haszn√°lj√°k sz√°m√≠t√≥g√©pes mem√≥riac√≠mek, sz√≠nek √©s alacsony szint≈± programoz√°s sor√°n.

- **Sz√≠nek**: A webfejleszt√©sben a sz√≠nek hexadecim√°lis k√≥dokkal (pl. `#FF5733`) vannak √°br√°zolva.

```javascript
let color = 0xFF5733;  // Hexadecim√°lis sz√≠nk√≥d
console.log(color.toString(16));  // Hexadecim√°lisk√©nt ki√≠rja: 'ff5733'
```

- **Mem√≥riac√≠mek**: A mem√≥riac√≠mek √°br√°zol√°s√°n√°l is gyakori a hexadecim√°lis form√°tum, mivel a g√©pek alacsony szint≈± kezel√©se sor√°n a mem√≥riac√≠mek k√∂nnyebben kezelhet≈ëk √≠gy.

```javascript
let address = 0x7FFE23;  // Mem√≥riac√≠m
console.log(address);  // Ki√≠rja a c√≠m hexadecim√°lis √©rt√©k√©t
```

#### **Bin√°ris sz√°mrendszer (Binary)**
A bin√°ris sz√°mrendszer a sz√°m√≠t√≥g√©pek bels≈ë m≈±k√∂d√©s√©ben alapvet≈ë szerepet j√°tszik, mivel a sz√°m√≠t√≥g√©pek biteken alapul√≥ inform√°ci√≥t t√°rolnak √©s dolgoznak fel.

- **Bitwise m≈±veletek**: Bin√°ris sz√°mokkal v√©gezhet√ºnk bitwise m≈±veleteket, p√©ld√°ul bitelcs√∫sztat√°st vagy bitenk√©nti √∂sszead√°st.

```javascript
let a = 0b1010;  // 10 bin√°ris form√°ban
let b = 0b1100;  // 12 bin√°ris form√°ban
let result = a & b;  // Bitwise AND m≈±velet (csak azokat az √©rtelemezz√ºk, ahol mindk√©t bit 1)
console.log(result.toString(2));  // Bin√°risan ki√≠rja: '1000' (8)
```

#### **Okt√°lis sz√°mrendszer (Octal)**
Az okt√°lis sz√°mrendszert r√©gebben f≈ëk√©nt rendszerszint≈± programoz√°sban haszn√°lt√°k, √©s a Unix rendszerekben a f√°jlok jogosults√°gait okt√°lis form√°ban √°br√°zolj√°k.

- **F√°jlok jogosults√°gai (Unix)**: A Unix-alap√∫ rendszerekben a f√°jlok jogosults√°gait okt√°lis sz√°mokkal √°br√°zolj√°k, p√©ld√°ul `0755` jelenti a f√°jl olvas√°si √©s v√©grehajt√°si jogosults√°gait.

```javascript
let filePermissions = 0o755;  // Okt√°lis form√°tumban: rwxr-xr-x
console.log(filePermissions.toString(8));  // Okt√°lisk√©nt ki√≠rja: '755'
```

</details>

---

## Floating-point Literals

A **lebeg≈ëpontos liter√°lok** (floating-point literals) a JavaScriptben olyan sz√°mok, amelyek nem eg√©sz sz√°mok, hanem tizedest√∂rtek vagy tudom√°nyos jel√∂l√©ssel √≠rt sz√°mok. Ezeket a sz√°mokat a lebeg≈ëpontos sz√°m√°br√°zol√°s szab√°lyai szerint kezelik, √©s az **IEEE 754-es szabv√°nyt** haszn√°lj√°k.

A lebeg≈ëpontos liter√°loknak h√°rom f≈ë form√°ja van:

**Tizedespontos alak**:
   - Olyan sz√°m, amely tartalmaz egy tizedespontot (pl. `3.14`).
   - P√©ld√°k:
     ```javascript
     let pi = 3.14;
     let price = 19.99;
     let negativeNumber = -0.5;
     ```

**Tudom√°nyos jel√∂l√©s (exponenci√°lis alak)**:
   - A sz√°mot `e` vagy `E` ut√°n k√∂vetkez≈ë eg√©sz sz√°m exponens√©vel adjuk meg, amely a t√≠z hatv√°ny√°t jelzi.
   - P√©ld√°k:
     ```javascript
     let bigNumber = 1.23e6; // 1.23 * 10^6 = 1230000
     let smallNumber = 5e-3; // 5 * 10^-3 = 0.005
     ```

**Eg√©sz sz√°mk√©nt, de tizedesponttal √≠rt alak**:
   - M√©g ha nincs is sz√°m a tizedespont ut√°n, akkor is lebeg≈ëpontos sz√°mnak sz√°m√≠t.
   - P√©lda:
     ```javascript
     let wholeNumber = 10.0; // Lebeg≈ëpontos sz√°m
     ```

Tulajdons√°gok
- A JavaScriptben minden sz√°m (ak√°r eg√©sz, ak√°r lebeg≈ëpontos) a **Number** adatt√≠pushoz tartozik.
- A **lebeg≈ëpontos sz√°mok pontoss√°ga korl√°tozott**, √≠gy el≈ëfordulhatnak kerek√≠t√©si hib√°k, p√©ld√°ul:
  ```javascript
  console.log(0.1 + 0.2); // Nem pontosan 0.3, hanem 0.30000000000000004
  ```

#### Mire kell figyelni?
- **Kerek√≠t√©si hib√°k**: A lebeg≈ëpontos sz√°mok sz√°m√≠t√°sai nem mindig pontosak az √°br√°zol√°suk korl√°toz√°sai miatt.
- **Tizedespont haszn√°lata**: Ha tizedespontot haszn√°lsz, mindig lebeg≈ëpontos sz√°m lesz bel≈ële, m√©g akkor is, ha nincs ut√°na t√∂rt √©rt√©k.

<details className="dropdown-task">

  <summary><strong>Gyakorlati p√©ld√°k lebeg≈ëpontos liter√°lokra</strong></summary>

**Tizedespontos alak**
Olyan sz√°mok, amelyek tartalmaznak egy tizedespontot, √©s legal√°bb egy sz√°mjegy tal√°lhat√≥ a tizedespont ut√°n.

```javascript
// P√©lda 1
let pi = 3.14; // A pi √©rt√©ke tizedespontos sz√°mk√©nt

// P√©lda 2
let discount = 19.99; // Egy √°ru √°ra tizedespontos √©rt√©kkel

// P√©lda 3
let temperature = -7.5; // Negat√≠v tizedespontos sz√°m
```


**Tudom√°nyos jel√∂l√©s (exponenci√°lis alak)**
Olyan sz√°mok, amelyek az `e` vagy `E` ut√°n megadj√°k a sz√°m√≠tand√≥ t√≠z hatv√°ny√°t.

```javascript
// P√©lda 1
let bigNumber = 1.2e6; // 1.2 * 10^6 = 1200000

// P√©lda 2
let smallNumber = 4.5e-4; // 4.5 * 10^-4 = 0.00045

// P√©lda 3
let speedOfLight = 3e8; // 3 * 10^8 = 300,000,000 (a f√©ny sebess√©ge m√©ter/s)
```


**Eg√©sz sz√°mk√©nt, de tizedesponttal √≠rt alak**
Olyan sz√°mok, amelyek tizedespontot tartalmaznak, de a tizedespont ut√°n nem tal√°lhat√≥ sz√°mjegy.

```javascript
// P√©lda 1
let roundedValue = 10.0; // Eg√©sz sz√°m tizedesponttal

// P√©lda 2
let exactValue = 42.0; // Egy pontos eg√©sz √©rt√©k lebeg≈ëpontos form√°ban

// P√©lda 3
let negativeWhole = -5.0; // Negat√≠v eg√©sz sz√°m tizedesponttal
```


  </details>


<details className="dropdown-task">

  <summary><strong>Melyikkel hol tal√°lkozhatunk?</strong></summary>

---

**Tizedespontos alak**

V√°s√°rl√°sn√°l egy term√©k √°r√°nak kezel√©se
```javascript
let itemPrice = 49.99; // Egy term√©k √°ra forintban
let taxRate = 0.27; // √ÅFA-kulcs (27%)
let totalPrice = itemPrice + itemPrice * taxRate;

console.log(`A teljes √°r √ÅFA-val: ${totalPrice.toFixed(2)} Ft`);
// Eredm√©ny: A teljes √°r √ÅFA-val: 63.49 Ft
```
> Az √°rak pontos kezel√©se p√©nz√ºgyi alkalmaz√°sokban.

---

**Tudom√°nyos jel√∂l√©s (exponenci√°lis alak)**

Csillag√°szati sz√°m√≠t√°sok (p√©ld√°ul a F√∂ld √©s a Nap t√°vols√°ga)
```javascript
let earthToSunDistance = 1.496e11; // A F√∂ld √©s a Nap t√°vols√°ga m√©terben (149,600,000,000 m)
let lightSpeed = 3e8; // A f√©ny sebess√©ge m√©ter/m√°sodperc

let travelTime = earthToSunDistance / lightSpeed; // Utaz√°si id≈ë m√°sodpercben
console.log(`A f√©ny ${travelTime} m√°sodperc alatt √©r a Napb√≥l a F√∂ldre.`);
// Eredm√©ny: A f√©ny 498.6666666666667 m√°sodperc alatt √©r a Napb√≥l a F√∂ldre.
```
> Nagyon nagy vagy nagyon kicsi sz√°mok kezel√©se tudom√°nyos ter√ºleteken.


**Eg√©sz sz√°mk√©nt, de tizedesponttal √≠rt alak**

Id≈ëz√≠t√©s egy stopperben
```javascript
let elapsedTime = 10.0; // A stopperrel m√©rt id≈ë m√°sodpercben
let lapTime = 15.0; // Egy k√∂rid≈ë m√°sodpercben

let totalTime = elapsedTime + lapTime;
console.log(`Teljes id≈ë: ${totalTime} m√°sodperc.`);
// Eredm√©ny: Teljes id≈ë: 25 m√°sodperc.
```
> Amikor az eg√©sz sz√°m tizedespontos √°br√°zol√°sa egy√©rtelm≈±bb√© teszi az adatokat (pl. id≈ëm√©r√©sn√©l vagy pontos m√©rt√©kegys√©gekn√©l).


  </details>

---

## Sz√°melv√°laszt√≥k numerikus liter√°lokban 
A JavaScript lehet≈ëv√© teszi, hogy al√°h√∫z√°sjeleket (_) haszn√°lj numerikus liter√°lokban, hogy hosszabb sz√°mokat k√∂nnyebben olvashat√≥bb√° tegy√©l:  

- **Ezres tagol√°sra:** `let billion = 1_000_000_000;`  
- **Hexadecim√°lis b√°jtcsoportok tagol√°s√°ra:** `let bytes = 0x89_AB_CD_EF;`  
- **Bin√°ris bitek csoportos√≠t√°s√°ra:** `let bits = 0b0001_1101_0111;`  
- **Tizedes t√∂rtekn√©l is m≈±k√∂dik:** `let fraction = 0.123_456_789;`  

2020 elej√©n ez a funkci√≥ m√©g nem volt teljesen szabv√°nyos√≠tott.

---

## Arithmetic in JavaScript

Az **aritmetikai m≈±veletek a JavaScriptben** a programoz√°si nyelvben v√©gezhet≈ë alapvet≈ë matematikai m≈±veleteket jelenti, p√©ld√°ul az √∂sszead√°st, kivon√°st, szorz√°st √©s oszt√°st. Emellett kiterjedhet a bonyolultabb matematikai m≈±veletekre is, p√©ld√°ul hatv√°nyoz√°sra, marad√©kos oszt√°sra, √©s speci√°lis matematikai f√ºggv√©nyek haszn√°lat√°ra (mint a kerek√≠t√©s, gy√∂kvon√°s vagy trigonometriai m≈±veletek).

#### Alapvet≈ë m≈±veletek:
**√ñsszead√°s (+)**  
   ```javascript
   let a = 5;
   let b = 10;
   let c = a + b; // 15
   ```

**Kivon√°s (-)**  
   ```javascript
   let a = 10;
   let b = 3;
   let c = a - b; // 7
   ```

**Szorz√°s (*)**  
   ```javascript
   let a = 4;
   let b = 5;
   let c = a * b; // 20
   ```

**Oszt√°s (/)**  
   ```javascript
   let a = 20;
   let b = 4;
   let c = a / b; // 5
   ```

**Marad√©kos oszt√°s (%)**  
   ```javascript
   let a = 10;
   let b = 3;
   let c = a % b; // 1 (mert 10 / 3 marad√©ka 1)
   ```

**Hatv√°nyoz√°s (**):  
   ```javascript
   let a = 2;
   let b = 3;
   let c = a ** b; // 8 (2 a harmadikon)
   ```

a JavaScriptben az **alapvet≈ë aritmetikai oper√°torokon** t√∫l (mint az √∂sszead√°s, kivon√°s, szorz√°s, oszt√°s) el√©rhet≈ëk **√∂sszetettebb matematikai m≈±veletek is**, amelyeket a **Math objektum** biztos√≠t.  

A Math objektum tartalmaz:
- **Met√≥dusokat**, amelyekkel k√ºl√∂nb√∂z≈ë matematikai sz√°m√≠t√°sokat v√©gezhet√ºnk (p√©ld√°ul n√©gyzetgy√∂k, kerek√≠t√©s, hatv√°nyoz√°s).
- **Konstansokat**, amelyek matematikai √°lland√≥kat reprezent√°lnak, mint p√©ld√°ul a œÄ (pi) vagy az Euler-f√©le sz√°m (*e*).


<details className="dropdown-task">

  <summary><strong>Math objektum met√≥dusai</strong></summary>

1. **Hatv√°nyoz√°s:**
   ```javascript
   Math.pow(2, 53); // => 9007199254740992
   // 2 az 53. hatv√°nyon.
   ```

2. **Kerek√≠t√©s a legk√∂zelebbi eg√©sz sz√°mra:**
   ```javascript
   Math.round(0.6); // => 1
   // Kerek√≠t√©s 1-re, mert 0.6 k√∂zelebb van az 1-hez, mint a 0-hoz.
   ```

3. **Felfel√© kerek√≠t√©s:**
   ```javascript
   Math.ceil(0.6); // => 1
   // Felfel√© kerek√≠t√©s a legk√∂zelebbi eg√©sz sz√°mra.
   ```

4. **Lefel√© kerek√≠t√©s:**
   ```javascript
   Math.floor(0.6); // => 0
   // Lefel√© kerek√≠t√©s a legk√∂zelebbi eg√©sz sz√°mra.
   ```

5. **Abszol√∫t √©rt√©k:**
   ```javascript
   Math.abs(-5); // => 5
   // Negat√≠v sz√°m pozit√≠vv√° alak√≠t√°sa.
   ```

6. **Legnagyobb √©rt√©k kiv√°laszt√°sa:**
   ```javascript
   Math.max(5, 10, 15); // => 15
   ```

7. **Legkisebb √©rt√©k kiv√°laszt√°sa:**
   ```javascript
   Math.min(5, 10, 15); // => 5
   ```

8. **V√©letlensz√°m gener√°l√°sa (0 √©s 1 k√∂z√∂tt):**
   ```javascript
   Math.random(); // P√©lda: 0.48391234
   ```

9. **Pi √©rt√©ke:**
   ```javascript
   Math.PI; // => 3.141592653589793
   ```

10. **Az Euler-f√©le sz√°m:**
    ```javascript
    Math.E; // => 2.718281828459045
    ```

11. **N√©gyzetgy√∂k:**
    ```javascript
    Math.sqrt(3); // => 1.7320508075688772
    ```

12. **K√∂bgy√∂k:**
    ```javascript
    Math.pow(3, 1 / 3); // => 1.4422495703074083
    ```

13. **Sinus:**
    ```javascript
    Math.sin(0); // => 0
    ```

14. **Term√©szetes logaritmus:**
    ```javascript
    Math.log(10); // => 2.302585092994046
    ```

15. **10-es alap√∫ logaritmus:**
    ```javascript
    Math.log(100) / Math.LN10; // => 2
    ```

16. **2-es alap√∫ logaritmus:**
    ```javascript
    Math.log(512) / Math.LN2; // => 9
    ```

17. **e a 3. hatv√°nyon:**
    ```javascript
    Math.exp(3); // => 20.085536923187668
    ```

18. **K√∂bgy√∂k egyszer≈±s√≠tett m√≥don (ES6):**
    ```javascript
    Math.cbrt(27); // => 3
    ```

19. **Pitagorasz-t√©tel (n√©gyzetek √∂sszege gy√∂kvon√°ssal):**
    ```javascript
    Math.hypot(3, 4); // => 5
    ```

20. **10-es alap√∫ logaritmus egyszer≈±s√≠tve:**
    ```javascript
    Math.log10(100); // => 2
    ```

21. **2-es alap√∫ logaritmus egyszer≈±s√≠tve:**
    ```javascript
    Math.log2(1024); // => 10
    ```

22. **(1 + x) term√©szetes logaritmusa (pontos kis x-n√©l):**
    ```javascript
    Math.log1p(0.001); // => 0.0009995003330834232
    ```

23. **e^x - 1 kis x-re pontosan:**
    ```javascript
    Math.expm1(0.001); // => 0.0010005001667083846
    ```

24. **Sz√°m el≈ëjele:**
    ```javascript
    Math.sign(-5); // => -1
    Math.sign(0);  // => 0
    Math.sign(5);  // => 1
    ```

25. **Optimaliz√°lt szorz√°s 32 bites sz√°mokkal:**
    ```javascript
    Math.imul(2, 3); // => 6
    ```

26. **Vezet≈ë null√°k sz√°ma 32 bites sz√°mban:**
    ```javascript
    Math.clz32(0xf); // => 28
    ```

27. **T√∂rt r√©szek lev√°g√°sa (trunc√°l√°s):**
    ```javascript
    Math.trunc(3.9); // => 3
    ```

28. **32 bites lebeg≈ëpontos sz√°m kerek√≠t√©se:**
    ```javascript
    Math.fround(1.337); // => 1.3370000123977661
    ```

29. **Hiperbolikus szinusz:**
    ```javascript
    Math.sinh(1); // => 1.1752011936438014
    ```

30. **Hiperbolikus arkusz-szinusz:**
    ```javascript
    Math.asinh(1); // => 0.881373587019543
    ```

</details>



A Math objektum a JavaScriptben egy el≈ëre defini√°lt eszk√∂zt√°r, amely lehet≈ëv√© teszi a programoz√≥knak, hogy egyszer≈±en el√©rjenek √©s haszn√°ljanak bonyolultabb matematikai m≈±veleteket √©s √©rt√©keket. √çgy nem kell ≈ëket k√©zzel implement√°lni, hanem egyszer≈±en hivatkozhat√≥k, p√©ld√°ul `Math.PI` vagy `Math.sqrt()`.

---

## Binary Floating-Point and Rounding Errors

A **bin√°ris lebeg≈ëpontos sz√°m√°br√°zol√°s √©s kerek√≠t√©si hib√°k** t√©m√°ja JavaScript-ben is fontos, mivel a lebeg≈ëpontos sz√°mok sz√°m√≠t√°sakor el≈ëfordulhatnak pontoss√°gi probl√©m√°k, amelyek hib√°s eredm√©nyekhez vezethetnek.

**Bin√°ris lebeg≈ëpontos sz√°m√°br√°zol√°s**

A sz√°m√≠t√≥g√©pek, k√∂zt√ºk a JavaScript, bin√°ris form√°ban (0-k √©s 1-ek sorozatak√©nt) t√°rolj√°k a sz√°mokat. A lebeg≈ëpontos sz√°mok, mint p√©ld√°ul a `1.23`, a sz√°m√≠t√°sokat seg√≠t≈ë IEEE 754 szabv√°ny alapj√°n ker√ºlnek √°br√°zol√°sra. Ez egy nagyon elterjedt szabv√°ny, de van egy h√°tr√°nya: nem minden sz√°mot lehet pontosan √°br√°zolni bin√°risan. 

**Mi√©rt van kerek√≠t√©si hiba?**

Bizonyos sz√°mok, amelyek a tizedes (decim√°lis) rendszerben v√©gesek, bin√°risan v√©gtelen sorozatot alkothatnak. P√©ld√°ul a `0.1` decim√°lis sz√°m bin√°risan nem √°br√°zolhat√≥ pontosan, mivel annak bin√°ris kiterjeszt√©se v√©gtelen hossz√∫.

Ez√©rt a JavaScript, amikor egy ilyen sz√°mot bin√°risan t√°rol, csak egy **k√∂zel√≠t≈ë √©rt√©ket** tud t√°rolni, ami kerek√≠t√©si hib√°kat okozhat a sz√°m√≠t√°sok sor√°n. 

**P√©lda kerek√≠t√©si hib√°ra**
Egy gyakori p√©lda, amely bemutatja a kerek√≠t√©si hib√°kat JavaScript-ben:

```javascript
console.log(0.1 + 0.2);  // 0.30000000000000004
```

B√°r logikailag azt v√°rn√°nk, hogy az eredm√©ny `0.3` lesz, a sz√°m√≠t√≥g√©p bels≈ë √°br√°zol√°sa miatt a val√≥s eredm√©ny `0.30000000000000004`. Ez a kerek√≠t√©si hiba a bin√°ris lebeg≈ëpontos √°br√°zol√°s k√∂vetkezm√©nye.

**JavaScript-ben tal√°lhat√≥ tov√°bbi tipikus hib√°k**
- A kerek√≠t√©si hib√°k nemcsak az egyszer≈± sz√°mokkal fordulnak el≈ë, hanem komplexebb m≈±veletek, mint p√©ld√°ul a szorz√°s, oszt√°s √©s a nagy sz√°m√∫ m≈±veletek sor√°n is.
- Az √∂sszead√°s √©s kivon√°s sor√°n is lehetnek pontatlans√°gok, k√ºl√∂n√∂sen, ha az egyes sz√°mok k√ºl√∂nb√∂z≈ë m√©rt√©k≈± kerek√≠t√©st ig√©nyelnek.


<details className="dropdown-task">

  <summary><strong>Tov√°bbi p√©lda kerek√≠t√©si probl√©m√°ra</strong></summary>

```javascript
let a = 0.7 + 0.1; 
let b = 0.6 + 0.2; 
a === b // => false: a k√©t √©rt√©k nem egyezik meg!
a === 0.8 // => false: 0.7 + 0.1 nem egyenl≈ë 0.8-cal
b === 0.8 // => true: 0.6 + 0.2 val√≥ban egyenl≈ë 0.8-cal
```

**Ki√©rt√©kel√©s:**

- **`let a = 0.7 + 0.1;`**
  - A sz√°m√≠t√≥g√©p a `0.7` √©s a `0.1` √∂sszead√°sakor a bin√°ris lebeg≈ëpontos √°br√°zol√°s miatt nem pontosan `0.8`-at kap, hanem egy olyan √©rt√©ket, ami nagyon k√∂zel √°ll hozz√° (p√©ld√°ul `0.7999999999999999`).

- **`let b = 0.6 + 0.2;`**
  - Itt a `0.6` √©s a `0.2` √∂sszead√°sakor a sz√°m√≠t√≥g√©p helyesen √°br√°zolja a `0.8`-at, teh√°t nincs kerek√≠t√©si hiba.

- **`a === b`**
  - Mivel `a` nem pontosan `0.8` (hanem annak egy k√∂zel√≠t≈ë √©rt√©ke), m√≠g `b` pontosan `0.8`, az √∂sszehasonl√≠t√°s `false`-t ad.

- **`a === 0.8`**
  - Az `a` v√°ltoz√≥ √©rt√©ke egy kicsit kisebb, mint `0.8`, ez√©rt az √∂sszehasonl√≠t√°s ism√©t `false`-t eredm√©nyez.

- **`b === 0.8`**
  - Itt a sz√°m√≠t√≥g√©p helyesen √°br√°zolja a `0.8`-at, ez√©rt az √∂sszehasonl√≠t√°s `true`-t ad.

</details>

---

## Arbitrary Precision Integers with BigInt

A **BigInt** egy olyan JavaScript t√≠pus, amely lehet≈ëv√© teszi a tetsz≈ëleges pontoss√°g√∫ eg√©sz sz√°mok kezel√©s√©t. Ez akkor v√°lik k√ºl√∂n√∂sen fontoss√°, ha olyan nagy sz√°mokkal dolgozol, amelyek meghaladj√°k a JavaScript alap√©rtelmezett **`Number`** t√≠pus√°nak t√°rol√°si k√©pess√©geit.

**Mi√©rt van sz√ºks√©g BigInt-re?**

A JavaScript alap√©rtelmezett sz√°mt√≠pusa a **`Number`**, amely IEEE 754 lebeg≈ëpontos sz√°m√°br√°zol√°s alapj√°n m≈±k√∂dik. Ez a t√≠pus azonban csak **64-bites** pontoss√°g√∫, √©s nem k√©pes pontosan kezelni a nagyon nagy eg√©sz sz√°mokat (p√©ld√°ul a milli√°rdokat, vagy m√©g nagyobbakat). Az `Number` t√≠pus legnagyobb √©rt√©ke k√∂r√ºlbel√ºl **1.8 √ó 10^308**, √©s a legkisebb √©rt√©ke **-1.8 √ó 10^308**. Azonban, ha enn√©l nagyobb eg√©sz sz√°mokra van sz√ºks√©g, a `BigInt` biztos√≠tja a sz√ºks√©ges pontoss√°got.

**A BigInt haszn√°lata**

A **BigInt** t√≠pus√∫ sz√°mokat a `n` bet≈± hozz√°ad√°s√°val hozhatjuk l√©tre a sz√°mok v√©g√©n. Ezen k√≠v√ºl **`BigInt()`** konstruktorral is l√©trehozhatunk BigInt objektumokat.

#### P√©ld√°k a haszn√°latra:

```javascript
// BigInt l√©trehoz√°sa liter√°lk√©nt
let largeNumber = 1234567890123456789012345678901234567890n;
console.log(largeNumber);  // 1234567890123456789012345678901234567890n

// BigInt l√©trehoz√°sa a BigInt() konstruktorral
let bigIntFromConstructor = BigInt("1234567890123456789012345678901234567890");
console.log(bigIntFromConstructor);  // 1234567890123456789012345678901234567890n
```

**Mi√©rt fontos a BigInt?**

N√©h√°ny alkalmaz√°sban √©s ter√ºleten a sz√°mok hatalmas m√©rt√©kben megn√∂vekedhetnek, p√©ld√°ul:
- **Kriptogr√°fia**: Nagy eg√©sz sz√°mok haszn√°lata a titkos√≠t√°shoz √©s al√°√≠r√°sokhoz.
- **P√©nz√ºgyi sz√°m√≠t√°sok**: Nagy tranzakci√≥k, nagy √©rt√©k≈± p√©nz√ºgyi sz√°m√≠t√°sok eset√©n.
- **Tudom√°nyos sz√°m√≠t√°sok**: Olyan esetekben, ahol nagyon nagy eg√©sz sz√°mokra van sz√ºks√©g.

A `BigInt` seg√≠ts√©g√©vel ezeket a probl√©m√°kat biztons√°gosan √©s pontosan kezelhetj√ºk.

**BigInt m≈±veletek**

A **BigInt** m≈±veletek alapvet≈ëen ugyan√∫gy m≈±k√∂dnek, mint a szok√°sos `Number` t√≠pus√∫ m≈±veletek, de figyeln√ºnk kell arra, hogy nem keverhetj√ºk ≈ëket k√∂zvetlen√ºl `Number` t√≠pus√∫ √©rt√©kekkel.

#### P√©ld√°k m≈±veletekre:

```javascript
let a = 1000000000000000000000000000n;  // Nagy sz√°m
let b = 2000000000000000000000000000n;  // M√©g nagyobb sz√°m

let sum = a + b;  // √ñsszead√°s
console.log(sum);  // 3000000000000000000000000000n

let product = a * b;  // Szorz√°s
console.log(product);  // 2000000000000000000000000000000000000000000000000000000000000000n
```

**BigInt √©s Number t√≠pus kever√©se**
A **BigInt** √©s a **Number** t√≠pusokat nem lehet k√∂zvetlen√ºl √∂sszeadni, kiv√©ve, ha mindk√©t t√≠pus ugyanarra a t√≠pusra van konvert√°lva.

#### Hiba p√©ld√°k:

```javascript
let bigIntNumber = 10n;
let regularNumber = 5;

console.log(bigIntNumber + regularNumber);  // TypeError: Cannot mix BigInt and other types
```

A fenti k√≥d hib√°t fog dobni, mert nem lehet k√∂zvetlen√ºl √∂sszeadni a `BigInt` √©s a `Number` t√≠pusokat.

#### Megold√°s:

A t√≠pusokat explicit m√≥don kell konvert√°lni, hogy √∂ssze lehessen adni ≈ëket:

```javascript
let bigIntNumber = 10n;
let regularNumber = 5;

console.log(bigIntNumber + BigInt(regularNumber));  // 15n
```

Vagy ford√≠tva:

```javascript
let bigIntNumber = 10n;
let regularNumber = 5;

console.log(Number(bigIntNumber) + regularNumber);  // 15
```


B√°r a `BigInt` lehet≈ëv√© teszi a tetsz≈ëleges pontoss√°g√∫ eg√©sz sz√°mok kezel√©s√©t, vannak bizonyos korl√°toz√°sok:
- Nem lehet haszn√°lni a **`BigInt` t√≠pus√∫ sz√°mokkal** a **`Math`** objektum met√≥dusait (pl. `Math.sqrt()`).
- A **`BigInt`** nem t√°mogatja az egyes oper√°torokat, mint a **`+`** sztringekhez, mivel a `BigInt` mindig eg√©sz sz√°mokkal dolgozik.

A **BigInt** a JavaScript-ben egy nagyon hasznos eszk√∂z, amikor nagy, pontos eg√©sz sz√°mokra van sz√ºks√©g. Ez k√ºl√∂n√∂sen hasznos lehet kriptogr√°fiai alkalmaz√°sokban, tudom√°nyos sz√°m√≠t√°sokban vagy b√°rmilyen m√°s helyzetben, ahol a sz√°mok m√©rete meghaladja a szok√°sos `Number` t√≠pus hat√°rait. Azonban fontos megjegyezni, hogy a `BigInt` √©s a `Number` t√≠pusokat nem lehet k√∂zvetlen√ºl keverni, ez√©rt megfelel≈ë t√≠puskonverzi√≥ra van sz√ºks√©g.

Ez a t√≠pus seg√≠t elker√ºlni a **lebeg≈ëpontos sz√°m√°br√°zol√°s** hib√°it √©s a kerek√≠t√©si probl√©m√°kat, amelyek a **`Number`** t√≠pus eset√©n el≈ëfordulhatnak.

---

## Dates and Times

A **D√°tumok √©s Id≈ëpontok** kezel√©se JavaScript-ben fontos t√©ma, mivel a legt√∂bb webalkalmaz√°sban sz√ºks√©g van d√°tumokkal val√≥ munk√°ra: p√©ld√°ul esem√©nyek id≈ëpontjainak megjelen√≠t√©se, d√°tumok k√∂z√∂tti sz√°m√≠t√°sok, helyi id≈ëz√≥n√°k kezel√©se stb. A JavaScript be√©p√≠tett `Date` objektuma √©s annak met√≥dusai seg√≠tenek a d√°tumok √©s id≈ëpontok kezel√©s√©ben.

#### **A Date objektum**
A JavaScript-ben a d√°tumokat √©s id≈ëpontokat a **`Date`** objektummal lehet kezelni. Ez az objektum az alap√©rtelmezett eszk√∂z a d√°tumok √©s id≈ëpontok l√©trehoz√°s√°hoz, manipul√°l√°s√°hoz √©s form√°z√°s√°hoz.

#### D√°tum l√©trehoz√°sa:

```javascript
// Aktu√°lis d√°tum √©s id≈ë
let currentDate = new Date();
console.log(currentDate);  // P√©lda: Mon Jan 27 2025 15:20:30 GMT+0100 (Central European Standard Time)

// D√°tum l√©trehoz√°sa √©v, h√≥nap, nap szerint
let specificDate = new Date(2025, 0, 27);  // Figyelem: a h√≥napok 0-t√≥l kezd≈ëdnek (0: janu√°r)
console.log(specificDate);  // P√©lda: Mon Jan 27 2025 00:00:00 GMT+0100 (Central European Standard Time)
```

- A `Date` konstruktor n√©lk√ºli h√≠v√°s a **currentDate** v√°ltoz√≥t az aktu√°lis d√°tummal √©s id≈ëponttal t√∂lti meg.
- A h√≥napok a `Date` konstruktorban **0-t√≥l 11-ig** terjednek, √≠gy a janu√°r h√≥napot a `0`-val kell megadni.

#### D√°tum l√©trehoz√°sa ISO 8601 form√°tumban:

```javascript
let isoDate = new Date('2025-01-27T15:20:30Z');
console.log(isoDate);  // Mon Jan 27 2025 16:20:30 GMT+0100 (Central European Standard Time)
```

A `new Date()` konstruktorhoz ISO 8601 form√°tumban megadott d√°tum is adhat√≥. Itt az "T" a d√°tum √©s az id≈ë k√∂z√∂tti elv√°laszt√≥, m√≠g a "Z" az UTC id≈ëz√≥n√°t jel√∂li.

#### **D√°tumok manipul√°l√°sa**
A `Date` objektummal k√ºl√∂nf√©le m≈±veleteket v√©gezhet√ºnk, p√©ld√°ul d√°tumok √∂sszehasonl√≠t√°sa, napok hozz√°ad√°sa, vagy a h√≥napok √©s √©vek m√≥dos√≠t√°sa.

#### Napok hozz√°ad√°sa, elt√°vol√≠t√°sa:

```javascript
let today = new Date();
console.log("Mai d√°tum:", today);

// Hozz√°adunk 5 napot
today.setDate(today.getDate() + 5);
console.log("5 nap m√∫lva:", today);
```

- A `setDate()` met√≥dus a h√≥nap napj√°t √°ll√≠tja be, √©s ha meghaladja a h√≥nap napjainak sz√°m√°t, akkor automatikusan √°tugrik a k√∂vetkez≈ë h√≥napra.

#### H√≥napok √©s √©vek manipul√°l√°sa:

```javascript
let anotherDate = new Date();
console.log("Eredeti d√°tum:", anotherDate);

// 3 h√≥nap hozz√°ad√°sa
anotherDate.setMonth(anotherDate.getMonth() + 3);
console.log("3 h√≥nap m√∫lva:", anotherDate);

// √âv m√≥dos√≠t√°sa
anotherDate.setFullYear(2026);
console.log("√öj √©v:", anotherDate);
```

- A `getMonth()` √©s `setMonth()` a h√≥napok kezel√©s√©re szolg√°lnak.
- A `getFullYear()` √©s `setFullYear()` az √©vet kezelik.

#### **D√°tumok √©s Id≈ëpontok √∂sszehasonl√≠t√°sa**
A d√°tumok √∂sszehasonl√≠t√°sa a JavaScript-ben egyszer≈±en t√∂rt√©nik, mivel a `Date` objektumok **kompar√°lhat√≥ak** (√∂sszehasonl√≠that√≥ak) m√°s `Date` objektumokkal.

```javascript
let date1 = new Date(2025, 0, 27);
let date2 = new Date(2025, 0, 28);

console.log(date1 < date2);  // true: date1 kor√°bbi mint date2
console.log(date1 > date2);  // false: date1 nem k√©s≈ëbbi mint date2
console.log(date1 === date2);  // false: d√°tumok nem egyeznek
```

- **`<`, `>`, `===`** oper√°torok haszn√°lhat√≥ak a d√°tumok √∂sszehasonl√≠t√°s√°ra.

#### **D√°tumok form√°z√°sa**
A `Date` objektumok nem rendelkeznek be√©p√≠tett m√≥dszerrel a rugalmas form√°z√°sra, de t√∂bb lehet≈ës√©g is van a d√°tumok form√°z√°s√°ra.

#### Alapvet≈ë met√≥dusok a `Date` objektumban:

```javascript
let date = new Date();

console.log(date.toString());  // "Mon Jan 27 2025 15:20:30 GMT+0100 (Central European Standard Time)"
console.log(date.toLocaleDateString());  // "2025. 01. 27."
console.log(date.toLocaleTimeString());  // "15:20:30"
```

- **`toString()`**: A `Date` objektumot teljes sz√∂veges form√°ban adja vissza.
- **`toLocaleDateString()`** √©s **`toLocaleTimeString()`**: A d√°tumot √©s az id≈ët lok√°lis form√°tumban adja vissza.


#### **Id≈ëz√≥n√°k kezel√©se**
JavaScript alap√©rtelmezetten a b√∂ng√©sz≈ë helyi id≈ëz√≥n√°j√°ban kezeli a d√°tumokat, de van lehet≈ës√©g az id≈ëz√≥n√°k kezel√©s√©re is.

```javascript
let utcDate = new Date('2025-01-27T15:20:30Z');  // UTC id≈ëz√≥n√°ban
console.log(utcDate.toLocaleString('en-US', { timeZone: 'America/New_York' }));  // New York id≈ëz√≥na
```

A `toLocaleString()` met√≥dus seg√≠ts√©g√©vel az id≈ëz√≥na is be√°ll√≠that√≥, hogy k√ºl√∂nb√∂z≈ë helyi id≈ëpontokat jelen√≠ts√ºnk meg.

#### **D√°tumok √©s id≈ëpontok helyes kezel√©se**
- **D√°tumok biztons√°gos kezel√©se**: Ha d√°tumokat kell t√°rolni √©s kezelni, mindig haszn√°ljunk ISO 8601 form√°tumot (`YYYY-MM-DD`), hogy elker√ºlj√ºk az elt√©r≈ë d√°tumform√°tumokb√≥l ad√≥d√≥ hib√°kat.
- **Egys√©ges id≈ëz√≥n√°k**: Ha a d√°tumokat √©s id≈ëpontokat t√∂bb k√ºl√∂nb√∂z≈ë id≈ëz√≥n√°ban haszn√°ljuk, √©rdemes figyelmet ford√≠tani a pontos id≈ëz√≥na kezel√©s√©re, p√©ld√°ul UTC vagy ISO 8601 form√°tumban.

A JavaScript Date objektum√°nak sz√°mos be√©p√≠tett met√≥dusa van, amelyek seg√≠tenek a d√°tumok √©s id≈ëpontok manipul√°l√°s√°ban, form√°z√°s√°ban √©s √∂sszehasonl√≠t√°s√°ban. √çme egy lista a legfontosabb met√≥dusokr√≥l, amiket √©rdemes ismerni:

<details className="dropdown-task">

  <summary><strong>L√©trehoz√°s</strong></summary>


- **`new Date()`**: L√©trehozza az aktu√°lis d√°tumot √©s id≈ëpontot.
- **`new Date(milliseconds)`**: L√©trehozza a d√°tumot a `milliseconds` alapj√°n (az 1970. janu√°r 1. 00:00:00 UTC-t√≥l eltelt milliszekundumok sz√°ma).
- **`new Date(dateString)`**: L√©trehozza a d√°tumot egy ISO 8601 form√°tumban megadott d√°tum karakterl√°nc alapj√°n.
- **`new Date(year, month, day, hours, minutes, seconds, milliseconds)`**: L√©trehozza a d√°tumot, amelyet √©v, h√≥nap, nap, √≥ra, perc, m√°sodperc √©s milliszekundumok alapj√°n hoz l√©tre. (A h√≥napok 0-t√≥l kezd≈ëdnek!)

</details>


<details className="dropdown-task">

  <summary><strong>D√°tum √©s id≈ë lek√©rdez√©se</strong></summary>


- **`getDate()`**: Visszaadja a h√≥nap napj√°t (1-31).
- **`getDay()`**: Visszaadja a h√©t napj√°t (0-6), ahol 0 a vas√°rnap.
- **`getFullYear()`**: Visszaadja az √©vet (4 sz√°mjegy≈±).
- **`getHours()`**: Visszaadja az √≥r√°t (0-23).
- **`getMilliseconds()`**: Visszaadja a milliszekundumokat (0-999).
- **`getMinutes()`**: Visszaadja a perceket (0-59).
- **`getMonth()`**: Visszaadja a h√≥napot (0-11), ahol 0 a janu√°r.
- **`getSeconds()`**: Visszaadja a m√°sodperceket (0-59).
- **`getTime()`**: Visszaadja a d√°tumot az 1970. janu√°r 1. 00:00:00 UTC-t√≥l eltelt milliszekundumok form√°j√°ban.
- **`getTimezoneOffset()`**: Visszaadja a helyi id≈ë √©s UTC k√∂z√∂tti elt√©r√©st percekben (pl. -60, ha az id≈ëz√≥na egy √≥r√°val el≈ër√©bb van az UTC-t≈ël).

</details>


<details className="dropdown-task">

  <summary><strong>D√°tum √©s id≈ë be√°ll√≠t√°sa</strong></summary>


- **`setDate(day)`**: Be√°ll√≠tja a h√≥nap napj√°t.
- **`setFullYear(year, month, day)`**: Be√°ll√≠tja az √©vet, h√≥napot √©s napot.
- **`setHours(hours, minutes, seconds, milliseconds)`**: Be√°ll√≠tja az √≥r√°t, percet, m√°sodpercet √©s milliszekundumot.
- **`setMilliseconds(milliseconds)`**: Be√°ll√≠tja a milliszekundumokat.
- **`setMinutes(minutes, seconds, milliseconds)`**: Be√°ll√≠tja a perceket, m√°sodperceket √©s milliszekundumokat.
- **`setMonth(month, day)`**: Be√°ll√≠tja a h√≥napot √©s a napot.
- **`setSeconds(seconds, milliseconds)`**: Be√°ll√≠tja a m√°sodperceket √©s a milliszekundumokat.
- **`setTime(milliseconds)`**: Be√°ll√≠tja a d√°tumot a megadott milliszekundumok alapj√°n, az 1970. janu√°r 1. 00:00:00 UTC-t√≥l eltelt id≈ë szerint.

</details>


<details className="dropdown-task">

  <summary><strong>Form√°z√°s</strong></summary>


- **`toDateString()`**: Visszaadja a d√°tumot csak a napra, h√≥napra, √©vre vonatkoz√≥ form√°tumban (pl. "Mon Jan 27 2025").
- **`toISOString()`**: Visszaadja a d√°tumot ISO 8601 form√°tumban (pl. "2025-01-27T15:20:30.000Z").
- **`toJSON()`**: Visszaadja a d√°tumot JSON-kompatibilis form√°tumban (√°ltal√°ban ugyanaz, mint az `toISOString()`).
- **`toLocaleDateString(locales, options)`**: A d√°tumot a helyi be√°ll√≠t√°soknak megfelel≈ëen adja vissza.
- **`toLocaleTimeString(locales, options)`**: Az id≈ët a helyi be√°ll√≠t√°soknak megfelel≈ëen adja vissza.
- **`toLocaleString(locales, options)`**: A d√°tumot √©s id≈ët a helyi be√°ll√≠t√°soknak megfelel≈ëen adja vissza.
- **`toString()`**: Visszaadja a d√°tumot teljes sz√∂veges form√°tumban (pl. "Mon Jan 27 2025 15:20:30 GMT+0100 (Central European Standard Time)").


</details>


<details className="dropdown-task">

  <summary><strong>Id≈ëz√≥n√°k</strong></summary>


- **`toLocaleString(locales, { timeZone })`**: K√ºl√∂nb√∂z≈ë id≈ëz√≥n√°k haszn√°lata a `toLocaleString` met√≥duson bel√ºl.


</details>


---

## Gyakorl√≥ feladatok

### Integer Literals


<details className="dropdown-task">

  <summary>
  <strong>Sz√°mok √∂sszege</strong>
  
  Adj √∂ssze h√°rom eg√©sz sz√°mot: **10**, **25** √©s **50**. √çrasd ki az eredm√©nyt a konzolra.
  </summary>

```javascript
let num1 = 10;
let num2 = 25;
let num3 = 50;

let sum = num1 + num2 + num3;

console.log(`A sz√°mok √∂sszege: ${sum}`);
```

</details>

<details className="dropdown-task">

  <summary>
  <strong>K√∂r ker√ºlete</strong>
  
Egy k√∂r sugara **7** egys√©g. Sz√°m√≠tsd ki a k√∂r ker√ºlet√©t az al√°bbi k√©plettel: 
 
- Ker√ºlet = 2 √ó r √ó œÄ

üëâ Haszn√°lj Math.PI-t a œÄ √©rt√©k√©re.
  
  </summary>

```javascript
let radius = 7; // A k√∂r sugara
let circumference = 2 * radius * Math.PI; // K√∂r ker√ºlete

console.log(`A k√∂r ker√ºlete: ${circumference.toFixed(2)} egys√©g`);
```



</details>

<details className="dropdown-task">

  <summary>
  <strong>Marad√©kos oszt√°s</strong>
  
  Egy s√ºtem√©nyes dobozban **28** s√ºtem√©ny van, √©s 5 ember k√∂z√∂tt szeretn√©d sz√©tosztani. Sz√°m√≠tsd ki:  
  - H√°ny darabot kap mindenki (eg√©sz oszt√°s eredm√©nye).  
  - Mennyi s√ºtem√©ny marad a dobozban.

  </summary>

```javascript
let totalCookies = 28; // S√ºtem√©nyek sz√°ma
let people = 5; // Emberek sz√°ma

let cookiesPerPerson = Math.floor(totalCookies / people); // S√ºtem√©nyek egyenl≈ë eloszt√°sa
let remainingCookies = totalCookies % people; // Marad√©k s√ºtem√©nyek

console.log(`Mindenki kap: ${cookiesPerPerson} s√ºtem√©nyt`);
console.log(`A dobozban marad: ${remainingCookies} s√ºtem√©ny`);
```


</details>

<details className="dropdown-task">

  <summary>
  <strong>P√°ros vagy p√°ratlan sz√°m?</strong>
  
  √çrj egy programot, amely megvizsg√°lja, hogy egy adott eg√©sz sz√°m (**12345**) p√°ros vagy p√°ratlan. Az eredm√©nyt √≠rasd ki a konzolra.
  
  </summary>

```javascript
let number = 12345; // Vizsg√°land√≥ sz√°m

if (number % 2 === 0) {
  console.log(`${number} p√°ros sz√°m`);
} else {
  console.log(`${number} p√°ratlan sz√°m`);
}
```


</details>

<details className="dropdown-task">

  <summary>
  <strong>Fibo-sorozat els≈ë 5 eleme</strong>

  A Fibonacci-sorozat els≈ë √∂t eleme **0**, **1**, **1**, **2**, **3**. Sz√°mold ki √©s √≠rasd ki a 6. elem √©rt√©k√©t is!  
A Fibonacci-sorozat k√©plete: **F(n) = F(n-1) + F(n-2)** 

  </summary>

```javascript
let fib1 = 0; // Els≈ë elem
let fib2 = 1; // M√°sodik elem
let fib3 = fib1 + fib2; // Harmadik elem
let fib4 = fib2 + fib3; // Negyedik elem
let fib5 = fib3 + fib4; // √ñt√∂dik elem
let fib6 = fib4 + fib5; // Hatodik elem

console.log(`Fibonacci-sorozat els≈ë 5 eleme: ${fib1}, ${fib2}, ${fib3}, ${fib4}, ${fib5}`);
console.log(`A Fibonacci-sorozat 6. eleme: ${fib6}`);
```



</details>




### Floating-point Literals

<details className="dropdown-task">

  <summary>
  <strong>Ad√≥ kisz√°m√≠t√°s</strong><br/>
Egy term√©k √°ra **19,99 Ft**, az √ÅFA **27%**. Sz√°m√≠tsd ki √©s √≠rasd ki:  
- Az √ÅFA √∂sszeg√©t.
- A term√©k v√©gs≈ë √°r√°t √ÅFA-val egy√ºtt.  

üëâ **Tipp:** Haszn√°lj `toFixed()`-et a kerek√≠t√©shez. Kerek√≠tsd az eredm√©nyeket k√©t tizedesjegyre.
  </summary>

**Megold√°s**
```javascript
let price = 19.99; // Term√©k √°ra
let taxRate = 0.27; // √ÅFA-kulcs (27%)

let taxAmount = price * taxRate; // √ÅFA √∂sszege
let finalPrice = price + taxAmount; // V√©gs≈ë √°r √ÅFA-val egy√ºtt

console.log(`√ÅFA √∂sszege: ${taxAmount.toFixed(2)} Ft`);
console.log(`V√©gs≈ë √°r: ${finalPrice.toFixed(2)} Ft`);
```

</details>

<details className="dropdown-task">

  <summary>
  <strong>T√°vols√°g kisz√°m√≠t√°sa</strong>

  Egy aut√≥ 4,5 √≥r√°n kereszt√ºl halad 72,8 km/h sebess√©ggel.  
- Sz√°m√≠tsd ki a megtett t√°vols√°got.  

üëâ **K√©plet:** T√°vols√°g = id≈ë √ó sebess√©g.
  </summary>
 
```javascript
let time = 4.5; // Id≈ë √≥r√°ban
let speed = 72.8; // Sebess√©g km/h-ban

let distance = time * speed; // T√°vols√°g kisz√°m√≠t√°sa

console.log(`Megtett t√°vols√°g: ${distance.toFixed(2)} km`);
```

</details>
<details className="dropdown-task">

  <summary>
  <strong>Kamatos kamat kisz√°m√≠t√°sa</strong>

Egy banki befektet√©s **100,000 Ft**, az √©ves kamatl√°b **5%**, √©s a p√©nz 3 √©vig kamatozik. Sz√°m√≠tsd ki, hogy mennyi lesz a befektet√©s √©rt√©ke a 3 √©v ut√°n.  

üëâ **K√©plet:** V√©g√∂sszeg = befektet√©s √ó (1 + kamatl√°b)^√©vek. Haszn√°ld a **Math.pow()** met√≥dust a hatv√°nyoz√°s kisz√°m√≠t√°s√°ra.
  </summary>

```javascript
let principal = 100000; // Befektet√©s √∂sszege
let interestRate = 0.05; // √âves kamatl√°b (5%)
let years = 3; // √âvek sz√°ma

let totalAmount = principal * Math.pow(1 + interestRate, years); // Kamatos kamat k√©plet

console.log(`A befektet√©s √©rt√©ke 3 √©v ut√°n: ${totalAmount.toFixed(2)} Ft`);
``` 

</details>
<details className="dropdown-task">

  <summary>
  <strong>Kerek√≠t√©si hiba vizsg√°lata</strong>
  
  √çrasd ki az al√°bbi m≈±velet eredm√©ny√©t:  
```javascript
console.log(0.1 + 0.2);
```  
Ezut√°n √≠rasd ki ugyanezt a kerek√≠tett form√°ban, 2 tizedesjegyre kerek√≠tve.  

üëâ **Tipp:** Vizsg√°ld meg, mi√©rt nem pontos az eredm√©ny! 
  
  </summary>

```javascript
let result = 0.1 + 0.2;

console.log(`Pontatlan eredm√©ny: ${result}`); // Kerek√≠t√©si hiba miatt nem pontos
console.log(`Kerek√≠tett eredm√©ny: ${result.toFixed(2)}`); // Kerek√≠t√©s 2 tizedesjegyre
```

</details>
<details className="dropdown-task">

  <summary>
  <strong>F√©ny utaz√°si ideje</strong>

  A Hold t√°vols√°ga a F√∂ldt≈ël k√∂r√ºlbel√ºl **384,400 km**, a f√©ny sebess√©ge **299,792 km/s**.  
  - Sz√°m√≠tsd ki, mennyi id≈ë alatt √©r el a f√©ny a Holdr√≥l a F√∂ldre m√°sodpercben.  
  </summary>

```javascript 
let moonDistance = 384400; // Hold t√°vols√°ga km-ben
let lightSpeed = 299792; // F√©ny sebess√©ge km/s-ban

let travelTime = moonDistance / lightSpeed; // Id≈ë = t√°vols√°g / sebess√©g

console.log(`A f√©ny utaz√°si ideje a Holdt√≥l a F√∂ldig: ${travelTime.toFixed(2)} m√°sodperc`);

``` 


</details>



### Math objektum met√≥dusai

<details className="dropdown-task">

  <summary>
  <strong>Hatv√°nyoz√°s</strong>

  Hat√°rozd meg 3 √∂t√∂dik hatv√°ny√°t.
  </summary>

```javascript
const result1 = Math.pow(3, 5);
console.log(`3 √∂t√∂dik hatv√°nya: ${result1}`);
```

</details>

<details className="dropdown-task">

  <summary>
  <strong>Kerek√≠t√©s a legk√∂zelebbi eg√©sz sz√°mra</strong>

  Kerek√≠tsd a 7.6 sz√°mot a legk√∂zelebbi eg√©sz sz√°mra.

  </summary>

```javascript
const result2 = Math.round(7.6);
console.log(`7.6 kerek√≠tve: ${result2}`);  
```

</details>

<details className="dropdown-task">

  <summary>
  <strong>Abszol√∫t √©rt√©k</strong>

Hat√°rozd meg a -15 abszol√∫t √©rt√©k√©t
  </summary>

```javascript
const result5 = Math.abs(-15);
console.log(`-15 abszol√∫t √©rt√©ke: ${result5}`);
```

</details>


<details className="dropdown-task">

  <summary>
	<strong>V√©letlensz√°m gener√°l√°sa</strong>
  
  Gener√°lj egy v√©letlensz√°mot 0 √©s 1 k√∂z√∂tt.
  </summary>

```javascript
const result8 = Math.random();
console.log(`V√©letlensz√°m 0 √©s 1 k√∂z√∂tt: ${result8}`);
```

</details>

<details className="dropdown-task">

  <summary>
	<strong>Legkisebb √©rt√©k kiv√°laszt√°sa</strong>
  
  V√°laszd ki a legkisebb √©rt√©ket a k√∂vetkez≈ë sz√°mok k√∂z√ºl: 34, 8, 19.
  </summary>

```javascript
const result7 = Math.min(34, 8, 19);
console.log(`A legkisebb sz√°m: ${result7}`);
```

</details>

<details className="dropdown-task">

  <summary>
	<strong>Pitagorasz-t√©tel</strong>

  Kisz√°m√≠tani egy der√©ksz√∂g≈± h√°romsz√∂g √°tfog√≥j√°t, ha az oldalai 3 √©s 4.
  </summary>

```javascript
const result13 = Math.sqrt(Math.pow(3, 2) + Math.pow(4, 2));
console.log(`A h√°romsz√∂g √°tfog√≥ja: ${result13}`);
```

</details>

### D√°tum √©s id≈ë

<details className="dropdown-task">

  <summary>
  <strong>Jelenlegi d√°tum ki√≠r√°sa</strong>

  √çrd ki a jelenlegi d√°tumot √©v-h√≥nap-nap form√°tumban.
  </summary>

```javascript
let date = new Date();
let currentDate = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
```

**Magyar√°zat:**  
- `new Date()` l√©trehozza az aktu√°lis d√°tumot √©s id≈ët.  
- `getFullYear()` visszaadja az aktu√°lis √©vsz√°mot.  
- `getMonth()` visszaadja a h√≥napot (0-t√≥l kezdve, teh√°t janu√°r = 0). Ez√©rt hozz√°adunk `+1`-et, hogy a h√≥nap sz√°m√°t megfelel≈ëen megkapjuk.  
- `getDate()` visszaadja a h√≥nap adott napj√°t.  
- Az √©rt√©keket `-` jellel f≈±zz√ºk √∂ssze, hogy √©v-h√≥nap-nap form√°tumot kapjunk.

</details>

<details className="dropdown-task">

  <summary>
  <strong>H√©t napja</strong>

  √çrd ki a h√©t napj√°t (pl. h√©tf≈ë, kedd, stb.) a jelenlegi d√°tum alapj√°n.
  </summary>

```javascript
let date = new Date();
let daysOfWeek = ['vas√°rnap', 'h√©tf≈ë', 'kedd', 'szerda', 'cs√ºt√∂rt√∂k', 'p√©ntek', 'szombat'];
let currentDay = daysOfWeek[date.getDay()];
```

**Magyar√°zat:**  
- A `getDay()` visszaadja az aktu√°lis napot 0-t√≥l 6-ig (vas√°rnap = 0, h√©tf≈ë = 1 stb.).  
- A `daysOfWeek` t√∂mb tartalmazza a h√©t napjainak neveit magyarul.  
- Az aktu√°lis nap nev√©t a t√∂mb index√©vel √©rj√ºk el, amelyet a `getDay()` visszaad.

</details>

<details className="dropdown-task">

  <summary>
  <strong>Jelenlegi id≈ë ki√≠r√°sa</strong>

  √çrd ki a jelenlegi id≈ët √≥ra:perc:m√°sodperc form√°tumban.
  </summary>

```javascript
let date = new Date();
let currentTime = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
```

**Magyar√°zat:**  
- `getHours()` visszaadja az aktu√°lis √≥r√°t.  
- `getMinutes()` visszaadja az aktu√°lis percet.  
- `getSeconds()` visszaadja az aktu√°lis m√°sodpercet.  
- Az √©rt√©keket `:` jellel f≈±zz√ºk √∂ssze, hogy √≥ra:perc:m√°sodperc form√°tumot kapjunk.

</details>

<details className="dropdown-task">

  <summary>
  <strong>D√°tum n√∂vel√©se egy nappal</strong>

  N√∂veld meg a mai d√°tumot egy nappal √©s √≠rd ki az √∫j d√°tumot.
  </summary>

```javascript
let date = new Date();
date.setDate(date.getDate() + 1);
let newDate = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
```

**Magyar√°zat:**  
- `getDate()` visszaadja az aktu√°lis napot.  
- `setDate()` be√°ll√≠tja a d√°tum napj√°t. Ha hozz√°adunk `+1`-et, akkor a k√∂vetkez≈ë napot kapjuk meg.  
- Az √∫j d√°tumot √©v-h√≥nap-nap form√°tumban √°ll√≠tjuk √∂ssze ugyan√∫gy, mint az els≈ë feladatban.

</details>

<details className="dropdown-task">

  <summary>
  <strong>K√ºl√∂nbs√©g k√©t d√°tum k√∂z√∂tt</strong>

  Sz√°mold ki k√©t d√°tum k√∂z√∂tti k√ºl√∂nbs√©get napokban.
  </summary>

```javascript
let date1 = new Date('2025-01-01');
let date2 = new Date('2025-01-10');
let difference = (date2 - date1) / (1000 * 60 * 60 * 24);
```

**Magyar√°zat:**  
- `new Date('2025-01-01')` √©s `new Date('2025-01-10')` k√©t adott d√°tumot hoz l√©tre.  
- A k√©t d√°tum k√∂z√∂tti k√ºl√∂nbs√©get kivon√°ssal sz√°moljuk (`date2 - date1`), amely milliszekundumban adja meg az √©rt√©ket.  
- A k√ºl√∂nbs√©get napokk√° alak√≠tjuk: 1000 milliszekundum = 1 m√°sodperc, 60 m√°sodperc = 1 perc, 60 perc = 1 √≥ra, 24 √≥ra = 1 nap. Ez√©rt osztjuk az √©rt√©ket `1000 * 60 * 60 * 24`-gyel.

</details>