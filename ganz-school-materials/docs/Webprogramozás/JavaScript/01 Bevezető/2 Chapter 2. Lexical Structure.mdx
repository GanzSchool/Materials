---
title: JavaScript nyelvi szab√°lyai
---

## Nyelvtani szab√°lyok √©s √≠r√°sm√≥d a JavaScriptben

A JavaScript egy **case-sensitive** nyelv, ami azt jelenti, hogy √©rz√©keny a kis √©s nagybet≈±kre. Ezen k√≠v√ºl kulcsszavakat, v√°ltoz√≥- √©s f√ºggv√©nyneveket, valamint egy√©b azonos√≠t√≥kat mindig pontosan a meghat√°rozott m√≥don kell √≠rni.

P√©ld√°ul a **while** kulcssz√≥t mindig kisbet≈±vel kell √≠rni. A **While** vagy a **WHILE** nem √©rtelmezhet≈ë a JavaScript sz√°m√°ra. A v√°ltoz√≥nevekn√©l azonban m√°r lehet√ºnk rugalmasabbak. Ha p√©ld√°ul azt szeretn√©nk, hogy a v√°ltoz√≥nk neve **online** legyen, akkor ezt a k√∂vetkez≈ë m√≥dokon is √≠rhatjuk: **Online**, **OnLine** √©s **ONLINE**, de err≈ël majd k√©s≈ëbb r√©szletesebben is sz√≥ lesz.

A JavaScript sok esetben figyelmen k√≠v√ºl hagyja a k√≥d elemei (tokenek) k√∂z√∂tt l√©v≈ë sz√≥k√∂z√∂ket. √Åltal√°ban a JavaScript a sort√∂r√©seket is figyelmen k√≠v√ºl hagyja, √≠gy a k√≥dot szabadon form√°zhatjuk a k√∂nnyebb olvashat√≥s√°g √©rdek√©ben.

---

## Comments

A **kommentek** a k√≥dban olyan megjegyz√©sek, amelyek seg√≠tenek a k√≥d meg√©rt√©s√©ben, de nem befoly√°solj√°k annak m≈±k√∂d√©s√©t. A JavaScript-ben k√©tf√©le kommentet haszn√°lhatunk: **egysoros** √©s **t√∂bbsoros** kommenteket.

#### Egysoros komment
Az egysoros komment egyetlen sorra terjed ki. Az al√°bbi m√≥don haszn√°lhat√≥:

```javascript
// Ez egy egysoros komment
let x = 5; // Ez is egy komment
```

A `//` ut√°n minden, amit √≠runk, a sor v√©g√©ig kommentnek sz√°m√≠t.

#### T√∂bbsoros komment
A t√∂bbsoros komment t√∂bb sorra is kiterjedhet. A kommentet a `/*` √©s `*/` jelek k√∂z√© kell √≠rni:

```javascript
/*
Ez egy t√∂bbsoros komment,
ami t√∂bb sorban is folytat√≥dhat.
*/
let y = 10;
```

Itt a `/*` jelzi a komment kezdet√©t, m√≠g a `*/` a v√©g√©t. Minden, ami k√∂z√∂tt√ºk van, kommentk√©nt lesz kezelve.

Ezek a kommentek seg√≠tenek a k√≥d olvashat√≥s√°g√°nak jav√≠t√°s√°ban, √©s nem befoly√°solj√°k annak m≈±k√∂d√©s√©t.

---

## Literals

<details className="dropdown-task">
  <summary><strong>A sz√≥ jelent√©se</strong></summary>



A **liter√°l** sz√≥ eredetileg a latin *littera* sz√≥b√≥l sz√°rmazik, ami "bet≈±t" vagy "√≠r√°sjegyet" jelent. A programoz√°sban a **liter√°l** kifejez√©s olyan konkr√©t, v√°ltoz√≥kt√≥l f√ºggetlen √©rt√©keket jel√∂l, amelyeket k√∂zvetlen√ºl a k√≥dban √≠runk le.

Az angolban a literal sz√≥b√≥l sz√°rmaz√≥ kifejez√©s magyar jelent√©se: sz√≥ szerinti, bet≈± szerinti.

A sz√≥ t√°gabb √©rtelemben azt jelenti, hogy valamit sz√≥ szerint, pontosan √∫gy, ahogy van, kifejez√ºnk. A programoz√°sban teh√°t egy liter√°l azt az √©rt√©ket jelenti, amit a programban k√∂zvetlen√ºl le√≠runk, p√©ld√°ul egy sz√°mot, sz√∂veget vagy logikai √©rt√©ket. P√©ld√°ul:

- A `42` sz√°m liter√°l, mert sz√≥ szerint az √©rt√©ke 42.
- A `"hello"` sz√∂veg liter√°l, mert sz√≥ szerint a karakterl√°ncot tartalmazza.

Ez√©rt a liter√°l egy olyan konkr√©t √©rt√©k, amelyet nem kell kisz√°m√≠tani, hanem egyszer≈±en megadunk.

</details>

A **liter√°lok** a JavaScriptben olyan √©rt√©kek, amelyeket k√∂zvetlen√ºl a k√≥dban adunk meg, √©s nem egy v√°ltoz√≥b√≥l sz√°rmaznak. A liter√°lok az alapvet≈ë adat t√≠pusok √©rt√©keinek k√∂zvetlen megjelen√≠t√©s√©re szolg√°lnak. A k√∂vetkez≈ë t√≠pus√∫ liter√°lokat haszn√°lhatjuk:

 **Sz√°mliter√°lok**: Egyszer≈± sz√°mok, p√©ld√°ul:
   ```javascript
   let a = 42;  // eg√©sz sz√°m liter√°l
   let b = 3.14; // lebeg≈ëpontos sz√°m liter√°l
   ```

**Sztringliter√°lok**: Karakterl√°ncok, amelyek egy karakterl√°ncot k√©pviselnek, √©s egyszeres (') vagy dupla (") id√©z≈ëjelek k√∂z√∂tt vannak.
   ```javascript
   let str1 = "Hello, World!";
   let str2 = 'JavaScript';
   ```

**Boolean liter√°lok**: Igaz (true) vagy hamis (false) √©rt√©kek.
   ```javascript
   let isActive = true;
   let isFinished = false;
   ```

**Objektumliter√°lok**: Az objektumokat egyszer≈±en hozhatjuk l√©tre kulcs-√©rt√©k p√°rokkal.
   ```javascript
   let person = { name: "John", age: 30 };
   ```

**T√∂mbliter√°lok**: Az elemeket z√°r√≥jelek k√∂z√© t√©ve hozhatunk l√©tre t√∂mb√∂ket.
   ```javascript
   let numbers = [1, 2, 3, 4];
   ```

**Null liter√°l**: A `null` √©rt√©k, amely azt jelzi, hogy egy v√°ltoz√≥ √©rt√©ke nincs be√°ll√≠tva.
   ```javascript
   let emptyValue = null;
   ```

**Template liter√°lok**: A backtick (`) karakterek k√∂z√∂tt megadott karakterl√°ncok, amelyek lehet≈ëv√© teszik v√°ltoz√≥k be√°gyaz√°s√°t a sztringekbe.
   ```javascript
   let name = "Alice";
   let greeting = `Hello, ${name}!`; // Template literal
   ```

A liter√°lok teh√°t az alapvet≈ë adatokat kifejez≈ë szintaktikai elemek, amelyeket a JavaScript programokban k√∂zvetlen√ºl haszn√°lunk.

--- 
#### Azonos√≠t√≥k and Reserved szavak (kulcsszavak)

#### **Identifiers** (Azonos√≠t√≥k) a JavaScriptben

Az **azonos√≠t√≥k** olyan nevek, amelyeket v√°ltoz√≥k, f√ºggv√©nyek, objektumok, vagy m√°s elemek azonos√≠t√°s√°ra haszn√°lsz a k√≥dban. Az azonos√≠t√≥k lehetnek saj√°t, √°ltalad v√°lasztott nevek vagy a nyelv √°ltal el≈ëre defini√°lt nevek.

#### **Szab√°lyok az azonos√≠t√≥khoz**:
1. **Kezd≈ëkarakter**:
   - Az azonos√≠t√≥ **bet≈±vel** (a-z, A-Z), al√°h√∫z√°ssal (`_`), vagy doll√°rjellel (`$`) kell kezd≈ëdj√∂n.
   - **Sz√°m** nem lehet az els≈ë karakter.
     ```javascript
     let validName = "OK"; // √ârv√©nyes
     let _private = "Hidden"; // √ârv√©nyes
     let $currency = "USD"; // √ârv√©nyes
     // let 1variable = "Error"; // Hiba
     ```

2. **K√∂vetkez≈ë karakterek**:
   - Lehetnek bet≈±k, sz√°mok, al√°h√∫z√°s (`_`) vagy doll√°rjelek (`$`).
     ```javascript
     let name1 = "John"; // √ârv√©nyes
     let my_var = "Variable"; // √ârv√©nyes
     ```

3. **√ârz√©kenyek a kis- √©s nagybet≈±kre**:
   - A JavaScript megk√ºl√∂nb√∂zteti a kis- √©s nagybet≈±ket.
     ```javascript
     let apple = "fruit";
     let Apple = "company";
     console.log(apple); // "fruit"
     console.log(Apple); // "company"
     ```

4. **Kulcsszavak nem haszn√°lhat√≥k azonos√≠t√≥k√©nt** (l√°sd lentebb).


#### **Reserved Words** (Kulcsszavak) a JavaScriptben

A **foglalt szavak** olyan szavak, amelyeket a JavaScript maga haszn√°l bizonyos funkci√≥khoz vagy szintaxis r√©szek√©nt. Ezeket **nem lehet azonos√≠t√≥k√©nt haszn√°lni**.

#### **Kulcsszavak (Keywords)**:
Olyan szavak, amelyek a JavaScript szintaxis√°nak r√©sz√©t k√©pezik, p√©ld√°ul:
```javascript
let, const, var, if, else, switch, case, break, for, while, do, return, function, class, extends, try, catch, finally, throw, import, export, new, delete, typeof, instanceof, in, this, super, static
```

#### **F√ºggv√©nyek √°ltal foglalt szavak**:
P√©ld√°k: `eval`, `arguments`.

#### **J√∂v≈ëbeni foglalt szavak**:
Ezek olyan szavak, amelyeket a JavaScript k√©s≈ëbbi verzi√≥iban tervezhetnek kulcssz√≥k√©nt haszn√°lni:
```javascript
enum, implements, interface, package, private, protected, public
```

#### **P√©ld√°k √©s hib√°k**:

1. **Foglalatlan sz√≥**:
   ```javascript
   let myVariable = 10; // √ârv√©nyes
   ```

2. **Foglalt sz√≥**:
   ```javascript
   // let return = 5; // Hiba: "return" foglalt sz√≥
   ```

3. **√ârv√©nyes azonos√≠t√≥k**:
   ```javascript
   let _value = 100;
   let $dollar = "currency";
   let camelCase = true;
   ```

4. **√ârv√©nytelen azonos√≠t√≥k**:
   ```javascript
   // let 123abc = "error"; // Hiba: Sz√°m nem lehet kezd≈ëkarakter
   // let my-var = "error"; // Hiba: K√∂t≈ëjel nem megengedett
   ```

#### **√ñsszefoglalva**:
- **Azonos√≠t√≥k**: Nevek, amelyeket te adhatsz v√°ltoz√≥knak, f√ºggv√©nyeknek, stb., bizonyos szab√°lyokat k√∂vetve.
- **Foglalt szavak**: A JavaScript be√©p√≠tett vagy fenntartott szavai, amelyeket nem haszn√°lhatsz azonos√≠t√≥k√©nt.

---

## Unicode a JavaScriptben

A **Unicode** a JavaScriptben (√©s m√°s programoz√°si nyelvekben) a karakterek glob√°lis szabv√°nyos√≠tott √°br√°zol√°sa. Lehet≈ëv√© teszi, hogy a k√≥d k√ºl√∂nb√∂z≈ë nyelvek √©s √≠r√°srendszerek karaktereit t√°mogassa, √≠gy glob√°lisan haszn√°lhat√≥v√° v√°lik.

1. **Sztringekben**:
   A JavaScript sztringek Unicode karaktereket t√°mogatnak, √≠gy gyakorlatilag b√°rmilyen karakter megadhat√≥ benn√ºk. P√©ld√°ul:
   ```javascript
   let text = "Hello, ‰∏ñÁïå!"; // Angol √©s k√≠nai karakterek
   console.log(text); // "Hello, ‰∏ñÁïå!"
   ```

2. **Unicode k√≥dpontok haszn√°lata**:
   Egy karakter Unicode k√≥dpontj√°t megadhatod `\u` szekvenci√°val (hexadecim√°lis form√°tumban), p√©ld√°ul:
   ```javascript
   let heart = "\u2764"; // Sz√≠v szimb√≥lum (‚ù§)
   console.log(heart); // ‚ù§
   ```

   A modernebb Unicode k√≥dpontok, amelyek meghaladj√°k a `\uFFFF` tartom√°nyt, a k√∂vetkez≈ë szintaxissal √©rhet≈ëk el:
   ```javascript
   let smiley = "\u{1F600}"; // üòÄ (Unicode k√≥dpont U+1F600)
   console.log(smiley); // üòÄ
   ```

3. **Unicode azonos√≠t√≥kban**:
   Az azonos√≠t√≥k (pl. v√°ltoz√≥nevek) Unicode karaktereket is tartalmazhatnak, bele√©rtve nem angol karaktereket is.
   ```javascript
   let √©l≈ël√©ny = "macska"; // √âkezetes karakterek az azonos√≠t√≥ban
   let ‰∏ñÁïå = "vil√°g"; // K√≠nai karakterek az azonos√≠t√≥ban
   console.log(√©l≈ël√©ny, ‰∏ñÁïå); // "macska vil√°g"
   ```

4. **Unicode Escape szekvenci√°k**:
   Sztringekben √©s regul√°ris kifejez√©sekben Unicode escape szekvenci√°kkal is megadhatod a karaktereket:
   ```javascript
   let unicodeEscape = "\u0041"; // 'A' bet≈± Unicode k√≥dja (U+0041)
   console.log(unicodeEscape); // A
   ```

5. **Unicode √©s regul√°ris kifejez√©sek**:
   A JavaScript regul√°ris kifejez√©sei t√°mogatj√°k a Unicode karaktereket. A `u` jelz≈ët haszn√°lhatod a Unicode m√≥d bekapcsol√°s√°hoz:
   ```javascript
   let regex = /\u{1F600}/u; // üòÄ karakter keres√©se
   console.log(regex.test("üòÄ")); // true
   ```

6. **Unicode hossz√∫ karakterek**:
   Egyes Unicode karakterek, mint p√©ld√°ul az emoji, t√∂bb "k√≥d egys√©gb≈ël" √°llhatnak, mert a JavaScript bels≈ëleg 16 bites UTF-16 k√≥dol√°st haszn√°l.
   ```javascript
   let emoji = "üòÄ";
   console.log(emoji.length); // 2 (mert k√©t k√≥d egys√©gb≈ël √°ll)
   ```

   Az ilyen karakterek helyes kezel√©se √©rdek√©ben haszn√°lhatod a **spread oper√°tort** vagy m√°s modern met√≥dusokat:
   ```javascript
   console.log([...emoji].length); // 1 (helyes karakterhossz)
   ```

**Gyakorlati p√©ld√°k**:

1. **Unicode szimb√≥lumok**:
   ```javascript
   let chess = "\u265A"; // Kir√°ly sakk figura (‚ôö)
   console.log(chess); // ‚ôö
   ```

2. **Emoji Unicode k√≥dokkal**:
   ```javascript
   let thumbsUp = "\u{1F44D}"; // üëç
   console.log(thumbsUp); // üëç
   ```

3. **Nem latin karakterek az azonos√≠t√≥kban**:
   ```javascript
   let √°r = 500;
   console.log(√°r); // 500
   ```0

**√ñsszefoglalva**:
A Unicode a karakterek glob√°lis szabv√°nyos √°br√°zol√°sa, amely biztos√≠tja, hogy a JavaScript t√°mogassa az √∂sszes √≠r√°srendszert, szimb√≥lumot, emoji-t, √©s speci√°lis karaktereket. Ennek k√∂sz√∂nhet≈ëen a k√≥dod univerz√°lisan alkalmazhat√≥ k√ºl√∂nb√∂z≈ë nyelveken √©s platformokon.

## Optional Semicolons

A **"Optional Semicolons"** (opcion√°lis pontosvessz≈ëk) a JavaScriptben arra utal, hogy a nyelv **√°ltal√°ban lehet≈ëv√© teszi a pontosvessz≈ëk kihagy√°s√°t** a k√≥dban, mivel a JavaScript **automatikusan besz√∫rja** a sz√ºks√©ges pontosvessz≈ëket a megfelel≈ë helyekre, amikor a k√≥dot futtatjuk. Ez az √∫gynevezett **Automatic Semicolon Insertion (ASI)** mechanizmus, amely megk√≠s√©rli a pontosvessz≈ëk automatikus hozz√°ad√°s√°t ott, ahol a programoz√≥ elfelejtette ≈ëket.

**Mi√©rt opcion√°lis a pontosvessz≈ë?**
A JavaScript a k√≥d elemz√©s√©hez √©s v√©grehajt√°s√°hoz k√©pes kital√°lni, hogy mikor van sz√ºks√©g egy pontosvessz≈ëre. Ha egy kifejez√©s vagy utas√≠t√°s v√©ge nem tartalmazza a pontosvessz≈ët, a JavaScript pr√≥b√°lja automatikusan behelyettes√≠teni a megfelel≈ë helyeken.

**P√©ld√°k, ahol a pontosvessz≈ë elhagyhat√≥**:

1. **Egyszer≈± kifejez√©s**:
   A k√∂vetkez≈ë k√≥d pontosvessz≈ëk n√©lk√ºl is m≈±k√∂dik:
   ```javascript
   let a = 5
   let b = 10
   let sum = a + b
   console.log(sum)
   ```
   Az ASI automatikusan hozz√°adja a sz√ºks√©ges pontosvessz≈ëket a kifejez√©sek v√©g√©n.

2. **F√ºggv√©nyh√≠v√°sok**:
   A f√ºggv√©nyek h√≠v√°sa ut√°n sem sz√ºks√©ges pontosvessz≈ë, ha a k√≥d j√≥l van strukt√∫r√°lva:
   ```javascript
   function greet() {
       console.log("Hello!");
   }
   greet()  // Nem sz√ºks√©ges pontosvessz≈ë
   ```

**Amikor a pontosvessz≈ë kihagy√°sa probl√©m√°t okozhat**:
B√°r a pontosvessz≈ëk opcion√°lisak, bizonyos esetekben az ASI nem m≈±k√∂dik megfelel≈ëen, √©s hib√°khoz vezethet. A leggyakoribb probl√©ma akkor fordul el≈ë, amikor a k√≥dnak k√©t sor k√∂z√∂tt **√©rtelmez√©si probl√©m√°ja** van, p√©ld√°ul a k√∂vetkez≈ë esetekben:

1. **Visszat√©r√©si utas√≠t√°sok**:
   Ha egy `return` kulcssz√≥val rendelkez≈ë sor ut√°n nem teszel pontosvessz≈ët, a JavaScript nem biztos, hogy helyesen √©rtelmezi a k√≥dot.
   ```javascript
   function test() {
       return
       {
           name: "John"
       }
   }

   console.log(test())  // undefined
   ```
   Itt a `return` sor ut√°n nem helyezhet≈ë el √∫j sor, mivel a JavaScript √∫gy √©rtelmezi, hogy a `return` utas√≠t√°st egyb≈ël befejezi. Ha a pontosvessz≈ët nem teszed a `return` ut√°n, akkor a k√∂vetkez≈ë sor egy √∫j blokkot kezd, √©s nem lesz visszaadva a k√≠v√°nt objektum.

2. **El≈ëtag n√©lk√ºli oper√°torok**:
   Az ilyen t√≠pus√∫ k√≥dban is probl√©m√°k lehetnek:
   ```javascript
   let x = 5
   let y = 10
   x
   + y
   ```
   Ebben az esetben a JavaScript **√∂sszeadja** az `x` √©s `y` √©rt√©keit, de az ASI nem biztos, hogy √∫gy m≈±k√∂dik, ahogy v√°rtuk.

**√ñsszefoglalva**:

- **Pontosvessz≈ëk opcion√°lisak** a JavaScriptben, mivel az ASI mechanizmus automatikusan hozz√°adja ≈ëket, ahol sz√ºks√©ges.
- **B√°r opcion√°lisak**, √©rdemes haszn√°lni ≈ëket a k√≥d tisztas√°g√°nak √©s olvashat√≥s√°g√°nak meg≈ërz√©s√©hez, valamint hogy elker√ºlj√ºk az olyan helyzeteket, ahol az ASI nem m≈±k√∂dik megfelel≈ëen.
- **Kihagy√°suk** n√©ha probl√©m√°kat okozhat, k√ºl√∂n√∂sen az olyan helyzetekben, ahol a JavaScript nem biztos abban, hogy mikor kell befejezni egy utas√≠t√°st.

<details className="dropdown-task">
  <summary><strong>ASI-r√≥l b≈ëvebben</strong></summary>


Az **ASI (Automatic Semicolon Insertion)** a JavaScript egy saj√°toss√°ga, amely lehet≈ëv√© teszi, hogy bizonyos helyzetekben a szintaktikai szab√°lyok szerint elv√°rt pontosvessz≈ëk (`;`) automatikusan hozz√°ad√°sra ker√ºljenek a JavaScript motor √°ltal, m√©g akkor is, ha a k√≥d √≠r√≥ja nem √≠rta be ≈ëket manu√°lisan.

#### Hogyan m≈±k√∂dik az ASI?
A JavaScript szab√°lyai szerint a pontosvessz≈ë opcion√°lis bizonyos helyeken, √©s az ASI mechanizmus automatikusan beilleszti azokat, ha:
- √öj sor van a k√≥dban, amely lez√°rhat egy √°ll√≠t√°st.
- A JavaScript egy √©rv√©nytelen szintaktikai helyzetbe ker√ºlne, ha nem lenne pontosvessz≈ë.
- Bizonyos kulcsszavak ut√°n (pl. `return`, `break`, `continue`), ha √∫j sor k√∂vetkezik.

#### P√©ld√°k az ASI m≈±k√∂d√©s√©re

#### Automatikusan beillesztett pontosvessz≈ë:
```javascript
let a = 5
let b = 10
console.log(a + b)
```

A fenti k√≥dot a JavaScript motor √≠gy √©rtelmezi:
```javascript
let a = 5;
let b = 10;
console.log(a + b);
```

#### Kulcsszavak √©s √∫j sor probl√©m√°i:
Ha `return` ut√°n √∫j sor kezd≈ëdik, az ASI beilleszti a pontosvessz≈ët az els≈ë sor v√©g√©re:
```javascript
function getValue() {
  return 
  42
}

console.log(getValue()) // undefined
```
Itt a JavaScript √≠gy √©rtelmezi:
```javascript
function getValue() {
  return; // automatikusan beillesztve
  42;
}
```
Ez√©rt a f√ºggv√©ny `undefined` √©rt√©ket ad vissza, nem pedig `42`.

#### Probl√©ma, ha nem egy√©rtelm≈±:
Az ASI nem mindig m≈±k√∂dik √∫gy, ahogyan v√°rn√°nk. P√©lda:
```javascript
let a = 10
let b = 20
let c = a + b
(a).toString()
```
Itt hib√°t kapunk, mert a JavaScript √≠gy pr√≥b√°lja √©rtelmezni:
```javascript
let a = 10;
let b = 20;
let c = a + b(a).toString(); // Hiba: b nem f√ºggv√©ny
```
Ez√©rt √©rdemes manu√°lisan hozz√°adni a pontosvessz≈ëket.

#### Mikor **ne b√≠zz** az ASI-ban?
- **K√≥d egy√©rtelm≈±s√©ge**: M√°s programoz√≥k k√∂nnyebben olvass√°k a k√≥dot, ha a pontosvessz≈ëk ott vannak, ahol kell.
- **Potenci√°lis hib√°k elker√ºl√©se**: Az olyan kulcsszavak ut√°n, mint a `return`, mindig egy sorba √≠rd a visszaadott √©rt√©ket.

#### √ñsszegz√©s
B√°r az ASI sok helyzetben megk√∂nny√≠ti a k√≥dol√°st, nem helyettes√≠ti a pontos szintaktikai fegyelmet. Javasolt, hogy k√∂vetkezetesen haszn√°lj pontosvessz≈ëket, mert √≠gy elker√ºlheted a nehezen k√∂vethet≈ë hib√°kat. Az ASI ink√°bb egy k√©nyelmi funkci√≥, nem pedig helyes programoz√°si gyakorlat.

---

JavaScriptben a pontosvessz≈ë (`;`) haszn√°lata nem mindig k√∂telez≈ë az **ASI** (Automatic Semicolon Insertion) miatt, de vannak olyan helyzetek, amikor **k√∂telez≈ë kitenni**, mert a hi√°nya szintaktikai hib√°t vagy v√°ratlan viselked√©st eredm√©nyezhet. N√©zz√ºk meg, mikor k√∂telez≈ë a pontosvessz≈ë haszn√°lata!

---

#### **K√≥dsorok √∂sszekapcsol√°sakor ugyanabban a sorban**
Ha k√©t k√ºl√∂n√°ll√≥ √°ll√≠t√°st (`statement`) egy sorban helyezel el, akkor k√∂telez≈ë a pontosvessz≈ë:
```javascript
let a = 5; let b = 10; console.log(a + b);
```

Ha nincs pontosvessz≈ë, a JavaScript nem tudja megk√ºl√∂nb√∂ztetni a k√ºl√∂n√°ll√≥ utas√≠t√°sokat, √©s szintaktikai hib√°t dob.

---

#### **Kifejez√©sek k√∂z√∂tt, ahol nem egy√©rtelm≈± az elv√°laszt√°s**
Egyes helyzetekben a JavaScript motor nem tudja helyesen √©rtelmezni a k√≥dot, ha nincs pontosvessz≈ë. P√©ld√°ul:
```javascript
let a = 5
let b = function() {}
[a].forEach(console.log)
```

Ez hib√°t okoz, mert a motor √≠gy pr√≥b√°lja √©rtelmezni:
```javascript
let b = function() {}[a].forEach(console.log);
```

A megold√°s:
```javascript
let a = 5;
let b = function() {};
[a].forEach(console.log);
```

---

#### **Return, Break, Continue kulcsszavak ut√°n**
Ha a `return`, `break`, vagy `continue` kulcssz√≥t k√∂vet≈ëen √∫j sor kezd≈ëdik, akkor k√∂telez≈ë a pontosvessz≈ë, hogy elker√ºld a helytelen √©rtelmez√©st.

#### Hib√°s p√©lda:
```javascript
function test() {
  return
  42
}
console.log(test()) // undefined
```

A JavaScript √≠gy √©rtelmezi:
```javascript
function test() {
  return; // Az ASI beilleszti
  42;    // Ez m√°r nem r√©sze a return √©rt√©knek
}
```

#### Helyes:
```javascript
function test() {
  return 42;
}
```

---

#### **For, While, Do-While ciklusok √ºres test√©ben**
Ha a ciklus t√∂rzse √ºres, k√∂telez≈ë a pontosvessz≈ë a k√≥d helyes √©rtelmez√©se √©rdek√©ben:
```javascript
for (let i = 0; i < 10; i++);
```

---

#### **Egy√©ni k√≥dblokkok eset√©n**
Ha a k√≥dblokkok k√∂z√∂tt pontosvessz≈ë n√©lk√ºl folytatod a k√≥dot, √©s az egy kifejez√©ssel kezd≈ëdik, a motor f√©lre√©rtelmezheti:
```javascript
let x = 10
(function() {
  console.log("Hi")
})()
```

A JavaScript ezt √≠gy √©rtelmezi:
```javascript
let x = 10(function() {
  console.log("Hi")
})();
```

A megold√°s:
```javascript
let x = 10;
(function() {
  console.log("Hi");
})();
```

---

#### **Ternary oper√°torok haszn√°latakor**
T√∂bbsoros ternary oper√°tor eset√©n z√°r√≥jelek vagy pontosvessz≈ë haszn√°lata seg√≠t elker√ºlni a hib√°kat:
```javascript
let result = condition
  ? value1
  : value2
// Itt nem k√∂telez≈ë, de aj√°nlott z√°rni az el≈ëz≈ë kifejez√©st.
```

---

#### Mikor nem sz√ºks√©ges?
Az ASI a k√∂vetkez≈ë helyzetekben automatikusan besz√∫rja a pontosvessz≈ët:
1. Egy sor v√©ge ut√°n, ha az √©rv√©nyes √°ll√≠t√°st z√°r.
2. Blokk (`{}`) v√©g√©n, ha nincs tov√°bbi szintaktikai elem.

P√©ld√°ul:
```javascript
let a = 10
let b = 20
console.log(a + b)
```

---

#### √Åltal√°nos aj√°nl√°s
M√≠g az ASI sokszor megk√∂nny√≠ti a k√≥d√≠r√°st, **k√∂vetkezetesen haszn√°lj pontosvessz≈ëket**:
- K√∂nnyebben olvashat√≥v√° teszed a k√≥dot.
- Elker√ºl√∂d a f√©lre√©rthet≈ë szitu√°ci√≥kat √©s hib√°kat.


</details>